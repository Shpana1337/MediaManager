# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'newdesign.ui'
#
# Created by: PyQt5 UI code generator 5.15.7
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

import sys
import sqlite3
from sys import platform
from pathlib import Path
from os import remove, stat
from collections import Counter
from math import ceil

import cv2
from screeninfo import get_monitors
from PyQt5.QtGui import QPixmap, QIcon
from PyQt5.QtMultimediaWidgets import QGraphicsVideoItem, QVideoWidget
from PyQt5.QtMultimedia import QMediaPlayer, QMediaContent
from PyQt5.QtCore import QUrl, QSize, Qt, QPropertyAnimation, QEasingCurve, QRect
from PyQt5.QtWidgets import QHBoxLayout, QVBoxLayout, QListWidget, QPushButton, QLabel, \
    QMainWindow, QFileDialog, QLineEdit, QApplication, QStyleFactory, QWidget, \
    QListWidgetItem, QGraphicsDropShadowEffect, QSpacerItem, QSizePolicy, QComboBox, QMessageBox, \
    QGraphicsOpacityEffect, QGraphicsScene, QGraphicsView, QSlider

from ui import Ui_MainWindow
from AnimatedEffects import AnimatedShadowEffect


class MMBody(QMainWindow):
    def __init__(self):
        super(MMBody, self).__init__()
        self.ui = Ui_MainWindow()
        self.ui.setupUi(self)
        self.setWindowTitle('МедиаМенеджер')

        self.animation = None
        self.LastIndex = None
        self.left_arrow = None
        self.right_arrow = None
        self.save_button = None
        self.cancel_button = None
        self.move_animation = None
        self.opacity_animation = None
        self.pressed_button_index = None
        self.button_cancel_selection = None
        self.video_slider = QSlider()
        self.right_window_label = QLabel()
        self.video_widget = QVideoWidget()
        self.media_player = QMediaPlayer()
        self.db_name = ""
        self.selection_type = 1
        self.first_pressed_index = -1
        self.second_pressed_index = -1
        self.previous_button_index = 0
        self.line_edits_mass = []
        self.list_widget_mass = []
        self.add_buttons_mass = []
        self.photo_button_mass = []
        self.delete_buttons_mass = []
        self.selected_files_mass = []
        self.button_is_photo_mass = []
        self.previous_tags_mass = []
        self.selected_files_way_mass = []
        self.paths_to_all_files_list = []
        self.shadow_effect = AnimatedShadowEffect()
        self.changed_tags_indexes_list = set()
        self.icons_cache_folder = Path('icons_cache')
        self.start_media = True
        self.right_window_is_open = False

        self.button_stylesheet_settings = "QPushButton {background-color: #c7c7c7; " \
                                          "border-radius: 7px; border: 1px solid #8a8a8a} " \
                                          "QPushButton::hover {background-color: #dedede; " \
                                          "QPushButton::pressed {background-color: #dadada;} " \
                                          "QToolTip {border: 1px solid black; background-color: white}"
        self.pushbutton_style_creator(pushbutton=self.ui.pushbutton_open_folder)
        self.db_init()
        self.window_resize(type_="start")

        self.ui.pushbutton_open_folder.pressed.connect(self.open_folder)


    def open_folder(self) -> None:
        for file in self.icons_cache_folder.iterdir():
            remove(file)

        dirlist = QFileDialog.getExistingDirectory(self, "Выбрать папку", ".")
        path = Path(dirlist)
        self.layout_cleaner(layout=self.ui.verticalLayout_11)
        files_was_founded = False
        self.paths_to_all_files_list = []
        self.changed_tags_indexes_list = set()
        video_formats = ('mov', 'avi', 'mp4')
        photo_formats = ('jpg', 'jpeg', 'png')

        for file in path.iterdir():
            _file_name = file.name
            _file_way = f"{dirlist}/{_file_name}"

            if _file_name.lower().endswith(photo_formats):
                files_was_founded = True
                self.block_creator(file_way=_file_way, file_is_photo=True)
                self.paths_to_all_files_list.append(_file_way)

            elif _file_name.lower().endswith(video_formats):
                files_was_founded = True
                self.block_creator(file_way=_file_way, file_is_photo=False)
                self.paths_to_all_files_list.append(_file_way)

        if files_was_founded:
            self.upper_lower_layouts_creating()

        self.opening_adding_tags()
        self.previous_tags_mass = self.all_tags_mass_creating()
        self.window_resize(type_="left_window_opening")


    def block_creator(self, file_way: str, file_is_photo: bool) -> None:
        """
        Функция создает блоки с медиафайлами, тегами и кнопками.

        :param ui.verticalLayout_11: Лэйаут scroll виджета.
        :param horizontal_layout: Главный layout блока.
        :param vertical_layout: Правый лэйаут блока с list widget и layout с кнопками.
        :param file_way: Путь к медиафайлу.
        :param file_is_photo: Булева переменная, показывает является ли файл фотографией.
        """
        # Сборка главного лэйаута блока
        horizontal_layout = QHBoxLayout()
        media_button = QPushButton()
        media_button.setMinimumSize(QSize(250, 170))

        if file_is_photo:
            icon = file_way
            self.button_is_photo_mass.append(True)
        # file is video
        else:
            icon = self.get_first_video_frame(file_way=file_way)
            self.button_is_photo_mass.append(False)

        media_button.setIcon(QIcon(icon))
        media_button.setIconSize(QSize(220, 160))
        media_button.setStyleSheet("QPushButton {background-color: white;border-radius: 7px; border: 1px solid #8a8a8a}"
                                   "QPushButton::hover {background-color: #eaeaea;}"
                                   "QPushButton::pressed {background-color: #dadada;}")
        self.set_shadow_effect(object_=media_button)
        horizontal_layout.addWidget(media_button)
        self.photo_button_mass.append(media_button)
        pressed_button_index = self.photo_button_mass.index(media_button)
        media_button.pressed.connect(lambda: self.right_window_changing(pressed_button_index=pressed_button_index))

        ## Сборка правого лэйаута
        vertical_layout = QVBoxLayout()
        list_widget = QListWidget()
        self.set_shadow_effect(object_=list_widget)
        button_delete_tag = QPushButton()
        button_delete_tag.setText('-')
        self.pushbutton_style_creator(pushbutton=button_delete_tag)
        button_delete_tag.setMinimumSize(50, 25)

        ### Сборка лэйаута для line edit и кнопки
        horizontal_layout_for_line_edit = QHBoxLayout()

        button_add_tag = QPushButton()
        button_add_tag.setText('+')
        self.pushbutton_style_creator(pushbutton=button_add_tag)
        button_add_tag.setMinimumSize(65, 25)

        line_edit = QLineEdit()
        line_edit.setPlaceholderText('Введите тег:')
        line_edit.setStyleSheet("QLineEdit {border-radius: 7px; border: 1px solid #8a8a8a; padding-left: 5px}")
        line_edit.setMinimumSize(70, 25)
        self.set_shadow_effect(object_=line_edit)

        horizontal_layout_for_line_edit.addWidget(line_edit)
        horizontal_layout_for_line_edit.addWidget(button_add_tag)
        ###

        vertical_layout.addWidget(list_widget)
        vertical_layout.addWidget(button_delete_tag)
        vertical_layout.addLayout(horizontal_layout_for_line_edit)
        ##

        horizontal_layout.addLayout(vertical_layout)
        #

        self.ui.verticalLayout_11.addLayout(horizontal_layout)

        self.line_edits_mass.append(line_edit)
        self.list_widget_mass.append(list_widget)
        self.add_buttons_mass.append(button_add_tag)
        self.delete_buttons_mass.append(button_delete_tag)

        pressed_button_index = self.add_buttons_mass.index(button_add_tag)

        button_add_tag.pressed.connect(lambda: self.add_tag(index_=pressed_button_index))
        button_delete_tag.pressed.connect(lambda: self.delete_tag(index_=pressed_button_index))


    def get_first_video_frame(self, file_way: str) -> str:
        """
        Функция сохраняет первый кадр из видео.

        :param file_way: Путь к видео.
        :return: Путь к первому кадру.
        """
        video = cv2.VideoCapture(file_way)
        video.set(cv2.CAP_PROP_POS_MSEC, 1 * 1000)
        # Считываем кадр
        ret, icon = video.read()
        # Если кадр успешно считан, сохраняем его
        if ret:
            cv2.imwrite(f"{self.icons_cache_folder}/{len(self.photo_button_mass)}.jpg", icon)

        return f"{self.icons_cache_folder}/{len(self.photo_button_mass)}.jpg"


    def opening_adding_tags(self) -> None:
        """
        Функция добавляет ко всем файлам теги, если они были ранее загружены в базу данных.
        Вызывается только после открытия папки с медиафайлами.
        """
        with sqlite3.connect(self.db_name) as db:
            cursor = db.cursor()
            _file_index = 0

            for file_way in self.paths_to_all_files_list:
                _file_id = stat(file_way, follow_symlinks=False).st_ino
                _device_id = stat(file_way, follow_symlinks=False).st_dev
                # Linux/Mac OS
                if self.db_name.startswith("lin"):
                    tag_indexes = cursor.execute("SELECT tag_index FROM media_files WHERE device_id = ? "
                                                 "AND file_id = ?", (_device_id, _file_id)).fetchall()
                # Windows
                else:
                    _disk_name = file_way.split(":/")[0][-1]
                    tag_indexes = cursor.execute("SELECT tag_index FROM media_files WHERE file_id = ? "
                                                 "AND disk_name = ?", (_file_id, _disk_name)).fetchall()

                if tag_indexes:
                    for el in tag_indexes:
                        index_ = el[0]
                        tag = cursor.execute("SELECT tag from tag_indexes WHERE tag_index = ?", (index_,)).fetchone()

                        if tag:
                            tag = tag[0]
                            self.list_widget_mass[_file_index].addItem(tag.capitalize())
                        else:
                            raise sqlite3.Error

                _file_index += 1


    def selection_type_change(self, value: int) -> None:
        """
        Функция меняет вид выделения файлов.

        :param value: Индекс выбранного метода выделения.
        """
        self.selection_type = value + 1
        self.right_block_cleaner()


    def upper_lower_layouts_creating(self) -> None:
        """
        Функция создает главное окно, в котором отображаются медиафайлы при открытии папки.
        """
        # Верхний лэйаут
        combo_box = QComboBox()
        combo_box.setMinimumSize(65, 25)
        combo_box.addItem('Одиночное выделение')
        combo_box.addItem('Выделение "от и до"')
        combo_box.addItem('Выборочное выделение')
        combo_box.currentIndexChanged.connect(self.selection_type_change)

        button_cancel_selection = QPushButton()
        button_cancel_selection.setText('Отменить выделение')
        button_cancel_selection.setMinimumSize(65, 25)
        button_cancel_selection.setMaximumSize(600, 25)
        button_cancel_selection.setEnabled(False)
        button_cancel_selection.pressed.connect(self.right_block_cleaner)
        self.button_cancel_selection = button_cancel_selection
        self.pushbutton_style_creator(pushbutton=button_cancel_selection)

        self.ui.upperbuttons_horizontal_layout.addWidget(combo_box)
        self.ui.upperbuttons_horizontal_layout.addWidget(button_cancel_selection)
        # Нижний лэйаут
        save_button = QPushButton()
        save_button.setText('Сохранить изменения')
        save_button.setMinimumSize(65, 25)
        save_button.setEnabled(False)
        save_button.pressed.connect(self.save_tags)
        self.save_button = save_button
        self.pushbutton_style_creator(pushbutton=save_button)

        cancel_button = QPushButton()
        cancel_button.setText('Отменить изменения')
        cancel_button.setMinimumSize(65, 25)
        cancel_button.setEnabled(False)
        cancel_button.pressed.connect(self.change_cancelling)
        self.cancel_button = cancel_button
        self.pushbutton_style_creator(pushbutton=cancel_button)

        self.ui.lowerbuttons_horizontal_layout.addWidget(save_button)
        self.ui.lowerbuttons_horizontal_layout.addWidget(cancel_button)


    def change_cancelling(self) -> None:
        for _index in self.changed_tags_indexes_list:
            self.list_widget_mass[_index].clear()
            self.list_widget_mass[_index].addItems(self.previous_tags_mass[_index])

        self.cancel_button.setEnabled(False)
        self.save_button.setEnabled(False)


    def save_tags(self) -> None:
        current_tags_list = self.all_tags_mass_creating()
        max_index = self.max_tag_index()

        with sqlite3.connect(self.db_name) as db:
            cursor = db.cursor()

            for i in self.changed_tags_indexes_list:
                _file_path = self.paths_to_all_files_list[i]
                _file_id = stat(_file_path, follow_symlinks=False).st_ino
                _device_id = stat(_file_path, follow_symlinks=False).st_dev
                _disk_name = _file_path.split(":/")[0][-1]
                # Добавление новых
                for tag in current_tags_list[i]:
                    if tag not in self.previous_tags_mass[i]:
                        _tag_index = cursor.execute("SELECT tag_index FROM tag_indexes WHERE tag = ?",
                                                    (tag,)).fetchone()
                        # Присваивание индекса новому тегу
                        if not _tag_index:
                            cursor.execute("INSERT INTO tag_indexes VALUES(?, ?, ?)", (max_index + 1, tag, 0))
                            max_index += 1
                            _tag_index = max_index

                        else:
                            _tag_index = _tag_index[0]
                        # Windows
                        if self.db_name.startswith("win"):
                            if not cursor.execute("SELECT FROM media_files WHERE disk_name = ? AND file_id = ? "
                                                  "AND tag_index = ?", (_disk_name, _file_id, _tag_index)).fetchone():
                                cursor.execute("INSERT INTO media_files VALUES(?, ?, ?)",
                                               (_disk_name, _file_id, _tag_index))
                                cursor.execute("UPDATE tag_indexes SET count = count + 1 WHERE tag = ?", (tag,))
                        # Linux/Mac OS
                        else:
                            if not cursor.execute("SELECT * FROM media_files WHERE device_id = ? AND file_id = ? "
                                                  "AND tag_index = ?", (_device_id, _file_id, _tag_index)).fetchone():
                                cursor.execute("INSERT INTO media_files VALUES(?, ?, ?)",
                                               (_device_id, _file_id, _tag_index))
                                cursor.execute("UPDATE tag_indexes SET count = count + 1 WHERE tag = ?", (tag,))

                db.commit()
                # Очистка удаленных тегов
                for old_tag in self.previous_tags_mass[i]:
                    if old_tag not in current_tags_list[i]:
                        index_and_count = cursor.execute("SELECT tag_index, count FROM tag_indexes WHERE tag = ?",
                                                         (old_tag,)).fetchone()

                        if not index_and_count:
                            raise sqlite3.Error

                        cursor.execute("DELETE FROM media_files WHERE device_id = ? AND file_id = ? AND tag_index = ?",
                                       (_device_id, _file_id, index_and_count[0]))

                        if index_and_count[1] - 1 == 0:
                            cursor.execute("DELETE FROM tag_indexes WHERE tag = ?", (old_tag,))

                        else:
                            cursor.execute("UPDATE tag_indexes SET count = count - 1 WHERE tag = ?", (old_tag,))

            db.commit()

        self.cancel_button.setEnabled(False)
        self.save_button.setEnabled(False)
        self.previous_tags_mass = self.all_tags_mass_creating()


    def max_tag_index(self) -> int:
        with sqlite3.connect(self.db_name) as db:
            cursor = db.cursor()
            max_index = cursor.execute("SELECT MAX(tag_index) FROM tag_indexes").fetchone()[0]

            if max_index:
                return max_index
            else:
                return 0


    def right_block_cleaner(self) -> None:
        self.layout_cleaner(layout=self.ui.verticalLayout_right_window)
        self.button_cancel_selection.setEnabled(False)
        self.right_window_is_open = False
        self.first_pressed_index = -1
        self.second_pressed_index = -1

        for _ in range(len(self.selected_files_mass)):
            self.selected_files_mass[_].setStyleSheet(
                "QPushButton {background-color: white; border-radius: 7px; border: 1px solid #8a8a8a}"
                "QPushButton::hover {background-color: #dedede;}"
                "QPushButton::pressed {background-color: #dadada;}")

        self.selected_files_mass = []
        self.selected_files_way_mass = []

        self.window_resize(type_="left_window_opening")


    def right_window_creating(self, pressed_button_index: int) -> None:
        """
        Функция создает расширенное главное окно с увеличенными медиафайлами.

        :param pressed_button_index: Индекс нажатого медиафайла.
        """
        if self.right_block_create_test(pressed_button_index=pressed_button_index):
            print(f'Ready to create a block! Selection_type = {self.selection_type}')
            self.window_resize(type_="right_window_opening")
            # Создание блока с фотографией
            if self.button_is_photo_mass[pressed_button_index]:
                self.photo_block_creating(pressed_button_index=pressed_button_index)
            # Создание блока с видео
            else:
                self.video_block_creating(pressed_button_index=pressed_button_index)

            self.right_window_is_open = True
            self.button_cancel_selection.setEnabled(True)


    def photo_block_creating(self, pressed_button_index: int) -> None:
        back_widget = QWidget()
        back_widget.setMaximumSize(600, 700)
        back_widget.setStyleSheet('QWidget {background-color: #f0f0f0; border: 1px solid #b9b9b9;}')

        local_vertical_layout = QVBoxLayout(back_widget)

        label = QLabel()
        label.setText("")
        label.setAlignment(Qt.AlignCenter)
        label.setStyleSheet("QLabel {border: 0px solid black;}")
        label.setMaximumSize(700, 500)
        self.right_window_label = label
        self.pressed_button_index = pressed_button_index

        spacer = QSpacerItem(1, 1, QSizePolicy.Expanding, QSizePolicy.Expanding)
        local_vertical_layout.addItem(spacer)
        local_vertical_layout.addWidget(label)

        spacer = QSpacerItem(1, 1, QSizePolicy.Expanding, QSizePolicy.Expanding)
        local_vertical_layout.addItem(spacer)

        horizontal_buttons_layout = self.arrow_layout_creating(pressed_button_index=pressed_button_index)

        local_vertical_layout.addLayout(horizontal_buttons_layout)
        self.ui.verticalLayout_right_window.addWidget(back_widget)
        self.previous_button_index = pressed_button_index


    def video_block_creating(self, pressed_button_index: int) -> None:
        back_widget = QWidget()
        back_widget.setMaximumSize(600, 700)
        back_widget.setStyleSheet('QWidget {background-color: #f0f0f0; border: 1px solid #b9b9b9;}')

        self.pressed_button_index = pressed_button_index

        layout = QVBoxLayout(back_widget)
        spacer = QSpacerItem(1, 1, QSizePolicy.Expanding, QSizePolicy.Expanding)
        layout.addItem(spacer)

        self.video_item = QGraphicsVideoItem()
        self.scene = QGraphicsScene(back_widget)
        self.scene.addItem(self.video_item)
        graphics_view = QGraphicsView(self.scene, back_widget)
        graphics_view.setGeometry(0, 0, 300, 300)
        self.media_player = QMediaPlayer(back_widget, QMediaPlayer.VideoSurface)
        self.media_player.setVideoOutput(self.video_item)

        horizontal_layout = QHBoxLayout()
        play_button = QPushButton()
        play_button.pressed.connect(self.play_button_pressed)
        self.pushbutton_style_creator(play_button)
        horizontal_layout.addWidget(play_button)
        layout.addLayout(horizontal_layout)

        horizontal_buttons_layout = self.arrow_layout_creating(pressed_button_index=pressed_button_index)
        layout.addLayout(horizontal_buttons_layout)

        self.start_media = True
        self.ui.verticalLayout_right_window.addWidget(back_widget)
        self.pressed_button_index = pressed_button_index


    def set_position(self, position: int) -> None:
        self.media_player.setPosition(position)


    def update_slider(self, position: int) -> None:
        self.video_slider.setValue(position)


    def play_button_pressed(self) -> None:
        if self.start_media:
            self.media_player.play()
            self.start_media = False
        else:
            self.media_player.pause()
            self.start_media = True


    def arrow_layout_creating(self, pressed_button_index: int) -> QWidget:
        horizontal_buttons_layout = QHBoxLayout()

        left_arrow = QPushButton()
        left_arrow.setText('<<')
        left_arrow.setMinimumSize(65, 25)
        self.left_arrow = left_arrow
        self.pushbutton_style_creator(left_arrow)
        left_arrow.pressed.connect(lambda: self.arrow_button_pressing(side="left"))

        right_arrow = QPushButton()
        right_arrow.setText('>>')
        right_arrow.setMinimumSize(65, 25)
        self.right_arrow = right_arrow
        self.pushbutton_style_creator(pushbutton=right_arrow)
        right_arrow.pressed.connect(lambda: self.arrow_button_pressing(side="right"))

        if pressed_button_index == 0:
            left_arrow.setEnabled(False)

        elif pressed_button_index == len(self.photo_button_mass) - 1:
            right_arrow.setEnabled(False)

        horizontal_buttons_layout.addWidget(left_arrow)
        horizontal_buttons_layout.addWidget(right_arrow)

        return horizontal_buttons_layout


    def right_window_changing(self, pressed_button_index: int) -> None:
        """
        :param self.previous_button_index: индекс предпоследней нажатой кнопки.
        :param selection_type: способ выделения фотографий (1 - одиночное, 2 - от и до, 3 - выборочное).
        :param selected_photo_mass: массив с указателями на кнопки выбранных фотографий.
        :param ready_to_create_block: флаг = True, когда выполнятся все условия для открытия блока
                                      для одного из вариантов выделения.
        :param pressed_button_index: Индекс нажатой кнопки.
        :param first_pressed_index: индекс первого нажатого элемента.
        :param second_pressed_index: индекс второго нажатого элемента.
        """
        if not self.right_window_is_open:
            self.right_window_creating(pressed_button_index=pressed_button_index)
            return

        if self.selection_type == 1:
            # Если выбрана фотография
            if self.button_is_photo_mass[pressed_button_index]:
                self.photo_button_mass[self.previous_button_index].setStyleSheet(
                    "QPushButton {background-color: white; border-radius: 7px; border: 1px solid #8a8a8a}"
                    "QPushButton::hover {background-color: #dedede;}"
                    "QPushButton::pressed {background-color: #dadada;}")

                self.photo_button_mass[pressed_button_index].setStyleSheet(
                    "QPushButton {background-color: #dadada; border-radius: 7px; border: 1px solid #8a8a8a}"
                    "QPushButton::hover {background-color: #dedede;}"
                    "QPushButton::pressed {background-color: #dadada;}")

                self.animated_file_change_1(icon_way=self.paths_to_all_files_list[pressed_button_index],
                                            duration=100)
                self.previous_button_index = pressed_button_index

                if pressed_button_index == 0:
                    self.left_arrow.setEnabled(False)
                    self.right_arrow.setEnabled(True)

                elif pressed_button_index == len(self.paths_to_all_files_list) - 1:
                    self.right_arrow.setEnabled(False)
                    self.left_arrow.setEnabled(True)

                else:
                    self.left_arrow.setEnabled(True)
                    self.right_arrow.setEnabled(True)
            # Если выбрано видео
            else:
                pass

        elif self.selection_type == 2:
            pass

        else:
            pass

        self.button_cancel_selection.setEnabled(True)


    def right_block_create_test(self, pressed_button_index: int):
        """
        Функция проверяет, выполнены ли все условия для создания расширенного окна с медиафайлами.
        """
        # Одиночное выделение
        if self.selection_type == 1:
            self.photo_button_mass[pressed_button_index].setStyleSheet(
                "QPushButton {background-color: #dadada; border-radius: 7px; border: 1px solid #8a8a8a}"
                "QPushButton::hover {background-color: #dedede;}"
                "QPushButton::pressed {background-color: #dadada;}")

            self.selected_files_mass = [self.photo_button_mass[pressed_button_index]]
            self.selected_files_way_mass = [self.paths_to_all_files_list[pressed_button_index]]
            return True
        # Выделение "от и до"
        elif self.selection_type == 2:
            return self.from_to_selection(pressed_button_index=pressed_button_index)
        # Выборочное выделение
        else:
            return self.selective_selection(pressed_button_index=pressed_button_index)


    def from_to_selection(self, pressed_button_index: int) -> bool:
        # Указание начала промежутка
        if self.first_pressed_index == -1:
            self.first_pressed_index = pressed_button_index
            self.photo_button_mass[pressed_button_index].setStyleSheet(
                "QPushButton {background-color: #dadada; border-radius: 7px; border: 1px solid #8a8a8a}"
                "QPushButton::hover {background-color: #dedede;}"
                "QPushButton::pressed {background-color: #dadada;}")
        # Указание конца промежутка
        elif self.second_pressed_index == -1:
            self.second_pressed_index = pressed_button_index
            # Если изначально был выбран конец промежутка, а не начало
            if self.first_pressed_index > self.second_pressed_index:
                self.first_pressed_index, self.second_pressed_index = self.second_pressed_index, self.first_pressed_index

            for i in range(self.first_pressed_index + 1, self.second_pressed_index + 1):
                self.photo_button_mass[i].setStyleSheet(
                    "QPushButton {background-color: #dadada; border-radius: 7px; border: 1px solid #8a8a8a}"
                    "QPushButton::hover {background-color: #dedede;}"
                    "QPushButton::pressed {background-color: #dadada;}")

            self.selected_files_mass = self.photo_button_mass[self.first_pressed_index:self.second_pressed_index + 1]
            self.selected_files_way_mass = self.paths_to_all_files_list[self.first_pressed_index:self.second_pressed_index + 1]

            return #True  # Раскомментировать, когда допишу функцию right_block_creator
        # Уже выбран промежуток (изменение промежутка)
        else:
            # Изменение начала промежутка
            if pressed_button_index < self.first_pressed_index:
                for i in range(pressed_button_index, self.first_pressed_index):
                    self.photo_button_mass[i].setStyleSheet(
                        "QPushButton {background-color: #dadada; border-radius: 7px; border: 1px solid #8a8a8a}"
                        "QPushButton::hover {background-color: #dedede;}"
                        "QPushButton::pressed {background-color: #dadada;}")

                self.first_pressed_index = pressed_button_index
            # Изменение конца промежутка
            elif pressed_button_index > self.second_pressed_index:
                for i in range(self.second_pressed_index + 1, pressed_button_index + 1):
                    self.photo_button_mass[i].setStyleSheet(
                        "QPushButton {background-color: #dadada; border-radius: 7px; border: 1px solid #8a8a8a}"
                        "QPushButton::hover {background-color: #dedede;}"
                        "QPushButton::pressed {background-color: #dadada;}")

                self.second_pressed_index = pressed_button_index
            # Обрезание промежутка (выбрана кнопка из диапазона)
            elif self.first_pressed_index < pressed_button_index < self.second_pressed_index:
                # Обрезаем начало (расстояние от начала до выбранного индекса наименьшее)
                if (pressed_button_index - self.first_pressed_index) < (self.second_pressed_index - pressed_button_index):
                    for i in range(self.first_pressed_index, pressed_button_index):
                        self.photo_button_mass[i].setStyleSheet(
                            "QPushButton {background-color: white; border-radius: 7px; border: 1px solid #8a8a8a}"
                            "QPushButton::hover {background-color: #dedede;}"
                            "QPushButton::pressed {background-color: #dadada;}")

                    self.first_pressed_index = pressed_button_index
                # Обрезаем конец
                else:
                    for i in range(pressed_button_index + 1, self.second_pressed_index + 1):
                        self.photo_button_mass[i].setStyleSheet(
                            "QPushButton {background-color: white; border-radius: 7px; border: 1px solid #8a8a8a}"
                            "QPushButton::hover {background-color: #dedede;}"
                            "QPushButton::pressed {background-color: #dadada;}")

                    self.second_pressed_index = pressed_button_index

            self.selected_files_mass = self.photo_button_mass[self.first_pressed_index:self.second_pressed_index + 1]
            self.selected_files_way_mass = self.paths_to_all_files_list[self.first_pressed_index:self.second_pressed_index + 1]

            return #True # Раскомментировать, когда допишу функцию right_block_creator
        return


    def selective_selection(self, pressed_button_index: int) -> bool:
        """
        :return: Функция возвращает True, если выполнены все условия для открытия right_block.
        """
        if self.paths_to_all_files_list[pressed_button_index] in self.selected_files_way_mass:
            self.photo_button_mass[pressed_button_index].setStyleSheet(
                "QPushButton {background-color: white; border-radius: 7px; border: 1px solid #8a8a8a}"
                "QPushButton::hover {background-color: #dedede;}"
                "QPushButton::pressed {background-color: #dadada;}")

            self.selected_files_way_mass.pop(pressed_button_index)
            self.selected_files_mass.pop(pressed_button_index)

        else:
            self.selected_files_way_mass.append(self.paths_to_all_files_list[pressed_button_index])
            self.selected_files_mass.append(self.photo_button_mass[pressed_button_index])

            self.photo_button_mass[pressed_button_index].setStyleSheet(
                "QPushButton {background-color: #dadada; border-radius: 7px; border: 1px solid #8a8a8a}"
                "QPushButton::hover {background-color: #dedede;}"
                "QPushButton::pressed {background-color: #dadada;}")

        if len(self.selected_files_mass) > 1:
            return #True

        else:
            self.button_cancel_selection.setEnabled(False)
            return


    def arrow_button_pressing(self, side: str):
        """
        Функция перелистывания медиафайлов в right_block.

        :param side: Переменная, обозначающая сторону, в которую будет выполняться перелистывание.
        """
        if self.selection_type == 1:
            if side == "left":
                self.photo_button_mass[self.previous_button_index].setStyleSheet(
                    "QPushButton {background-color: white; border-radius: 7px; border: 1px solid #8a8a8a}"
                    "QPushButton::hover {background-color: #dedede;}"
                    "QPushButton::pressed {background-color: #dadada;}")
                self.photo_button_mass[self.previous_button_index - 1].setStyleSheet(
                    "QPushButton {background-color: #dadada; border-radius: 7px; border: 1px solid #8a8a8a}"
                    "QPushButton::hover {background-color: #dedede;}"
                    "QPushButton::pressed {background-color: #dadada;}")

                icon_way = self.paths_to_all_files_list[self.previous_button_index - 1]
                self.selected_files_mass = [self.photo_button_mass[self.previous_button_index - 1]]
                self.selected_files_way_mass = [self.paths_to_all_files_list[self.previous_button_index - 1]]
                self.previous_button_index -= 1

                self.animated_file_change_1(icon_way=icon_way, duration=100)

                if self.previous_button_index == 0:
                    self.left_arrow.setEnabled(False)

                if not(self.right_arrow.isEnabled()):
                    self.right_arrow.setEnabled(True)
            # side = "right"
            else:
                self.photo_button_mass[self.previous_button_index].setStyleSheet(
                    "QPushButton {background-color: white; border-radius: 7px; border: 1px solid #8a8a8a}"
                    "QPushButton::hover {background-color: #dedede;}"
                    "QPushButton::pressed {background-color: #dadada;}")

                self.photo_button_mass[self.previous_button_index + 1].setStyleSheet(
                    "QPushButton {background-color: #dadada; border-radius: 7px; border: 1px solid #8a8a8a}"
                    "QPushButton::hover {background-color: #dedede;}"
                    "QPushButton::pressed {background-color: #dadada;}")

                self.selected_files_mass = [self.photo_button_mass[self.previous_button_index + 1]]
                self.selected_files_way_mass = [self.paths_to_all_files_list[self.previous_button_index + 1]]
                icon_way = self.paths_to_all_files_list[self.previous_button_index + 1]
                self.previous_button_index += 1

                self.animated_file_change_1(icon_way=icon_way, duration=100)

                if self.previous_button_index == len(self.photo_button_mass) - 1:
                    self.right_arrow.setEnabled(False)

                if not(self.left_arrow.isEnabled()):
                    self.left_arrow.setEnabled(True)


    def animated_file_change_1(self, icon_way: str, duration: int) -> None:
        object_ = self.defining_media_object()

        self.shadow_effect_init(duration=duration)
        self.shadow_effect.fading_animation_start()
        self.shadow_effect.animation.finished.connect(lambda: self.animated_file_change_2(icon_way=icon_way,
                                                                                          values=(1, 0),
                                                                                          duration=duration,
                                                                                          object_=object_))


    def animated_file_change_2(self, icon_way: str, values: tuple, duration: int, object_: QWidget) -> None:
        opacity_effect = QGraphicsOpacityEffect(object_)
        object_.setGraphicsEffect(opacity_effect)
        self.opacity_animation = QPropertyAnimation(opacity_effect, b"opacity")
        self.opacity_animation.setDuration(duration)
        self.opacity_animation.setStartValue(values[0])
        self.opacity_animation.setEndValue(values[1])
        self.opacity_animation.start()
        # Функция вызвана нажатием кнопки "Отменить выделение"
        if icon_way == "":
            self.opacity_animation.finished.connect(self.right_block_cleaner)
        # Функция вызвана от animated_file_change_1
        elif values[0] == 1:
            self.opacity_animation.finished.connect(lambda: self.animated_file_change_3(icon_way=icon_way,
                                                                                        duration=duration,
                                                                                        object_=object_))
        # Функция вызвана от animated_file_change_3
        else:
            self.opacity_animation.finished.connect(lambda: self.animated_file_change_4(duration=duration,
                                                                                        object_=object_))


    def animated_file_change_3(self, icon_way: str, duration: int, object_: QWidget) -> None:
        if type(object_) == QVideoWidget:
            pass

        elif type(object_) == QLabel:
            pixmap = QPixmap(icon_way).scaled(600, 400, aspectRatioMode=Qt.KeepAspectRatioByExpanding)
            object_.setPixmap(pixmap)

        else:
            raise TypeError

        self.animated_file_change_2(icon_way=icon_way, values=(0, 1), duration=duration, object_=object_)


    def animated_file_change_4(self, duration: int, object_: QWidget) -> None:
        self.shadow_effect_init(duration=duration)
        object_.setGraphicsEffect(self.shadow_effect)
        self.shadow_effect.rise_animation_start()


    def animated_opacity_change(self, values: tuple, duration: int, object_: QWidget) -> None:
        """
        Функция плавно меняет прозрачность заданного на вход объекта.
        """
        opacity_effect = QGraphicsOpacityEffect(object_)
        object_.setGraphicsEffect(opacity_effect)
        self.opacity_animation = QPropertyAnimation(opacity_effect, b"opacity")
        self.opacity_animation.setDuration(duration)
        self.opacity_animation.setStartValue(values[0])
        self.opacity_animation.setEndValue(values[1])
        self.opacity_animation.start()


    def shadow_effect_init(self, duration: int) -> None:
        self.shadow_effect = AnimatedShadowEffect()
        self.shadow_effect.animation.setDuration(duration)
        self.shadow_effect.setXOffset(0)
        self.shadow_effect.setYOffset(0)


    def defining_media_object(self) -> QWidget:
        """
        Функция определяет активный виджет.
        """
        # File is photo
        if self.button_is_photo_mass[self.pressed_button_index]:
            object_ = self.right_window_label
        # File is video
        else:
            object_ = self.scene

        return object_


    def add_tag(self, index_: int) -> None:
        """
        Функция добавляет тег(и) в list widgets.

        :param index_: Индекс измененного медиафайла. Равен -1, когда пользователь хочет добавить тег нажатием 'Enter'.
        """
        # Нажатие на кнопку +
        if index_ != -1:
            line_edit_text = self.line_edits_mass[index_].text()
            self.changed_tags_indexes_list.add(index_)

            if line_edit_text:
                already_exist_tags = []

                for i in range(self.list_widget_mass[index_].count()):
                    already_exist_tags.append(self.list_widget_mass[index_].item(i).text().lower())

                line_edit_text = line_edit_text.split(',')
                line_edit_text = list(set(line_edit_text))

                if already_exist_tags:
                    for tag in line_edit_text:
                        tag = tag.strip()

                        if tag != ' ' and tag != '' and tag.lower() not in already_exist_tags:
                            self.list_widget_mass[index_].addItem(tag)

                else:
                    for tag in line_edit_text:
                        tag = tag.strip()

                        if tag != ' ' and tag != '':
                            self.list_widget_mass[index_].addItem(tag)

                self.line_edits_mass[index_].clear()
        # Функция вызвана нажатием кнопки Enter
        else:
            for i in range(len(self.line_edits_mass)):
                if self.line_edits_mass[i].text() != '':
                    self.changed_tags_indexes_list.add(i)
                    self.add_tag(index_=i)
            return

        self.previous_and_present_tags_equal_test()


    def delete_tag(self, index_: int) -> None:
        """
        Функция удаляет тег(и) из list widgets.

        :param index_: Индекс измененного медиафайла.
        """
        a = self.list_widget_mass[index_].selectedIndexes()
        _selected_index = self.list_widget_mass[index_].count() - 1
        _items_mass = []

        for i in a:
            _selected_index = i.row()

        # Очистка и обратное заполнение listWidget
        for i in range(self.list_widget_mass[index_].count()):
            if i != _selected_index:
                item = self.list_widget_mass[index_].item(i)
                name = item.text()
                foreground = item.foreground()
                _items_mass.append([name, foreground])

        self.list_widget_mass[index_].clear()

        for i in range(len(_items_mass)):
            new_item = QListWidgetItem()
            new_item.setText(_items_mass[i][0])
            new_item.setForeground(_items_mass[i][1])
            self.list_widget_mass[index_].addItem(new_item)

        self.changed_tags_indexes_list.add(index_)
        self.previous_and_present_tags_equal_test()


    def previous_and_present_tags_equal_test(self) -> None:
        present_tags = self.all_tags_mass_creating()
        is_equal = True

        for i in self.changed_tags_indexes_list:
            # Проверка на содержание одинаковых элементов
            if Counter(present_tags[i]) != Counter(self.previous_tags_mass[i]):
                if not self.save_button.isEnabled():
                    self.save_button.setEnabled(True)
                    self.cancel_button.setEnabled(True)

                is_equal = False
                break

        if is_equal:
            self.save_button.setEnabled(False)
            self.cancel_button.setEnabled(False)


    def all_tags_mass_creating(self) -> list:
        """
        :return: Двумерный массив со всеми тегами.
        """
        all_tags_mass = []

        for i in range(len(self.list_widget_mass)):
            _mass = []
            if self.list_widget_mass[i].count() != 0:
                for j in range(self.list_widget_mass[i].count()):
                    _mass.append(self.list_widget_mass[i].item(j).text().lower())
            # добавляем в двумерный массив либо пустые массивы, если в лв нет тегов, либо массив с элементами лв
            all_tags_mass.append(_mass)

        return all_tags_mass


    def layout_cleaner(self, layout: QWidget) -> None:
        """
        Функция полностью очищает содержимое заданного на вход layout.
        """
        if layout is not None:
            while layout.count():
                item = layout.takeAt(0)
                widget = item.widget()

                if widget is not None:
                    layout.removeWidget(widget)
                    widget.deleteLater()
                else:
                    self.layout_cleaner(layout=item.layout())


    def keyPressEvent(self, e) -> None:
        # Главное окно с медиафайлами.
        if self.ui.tabWidget.currentIndex() == 0:
            if e.key() == Qt.Key_Return:
                self.add_tag(index_=-1)


    def db_init(self) -> None:
        """
        Функция инициализирует базу данных при запуске программы.
        """
        if platform.startswith("win"):
            self.db_name = "winDataBase.db"

            with sqlite3.connect("winDataBase.db") as db:
                cursor = db.cursor()
                cursor.executescript("""
                CREATE TABLE IF NOT EXISTS media_files (disk_name TEXT, file_id TEXT, tag_index BIGINT);
                CREATE TABLE IF NOT EXISTS tag_indexes (tag_index BIGINT, tag TEXT, count BIGINT);
                """)
                db.commit()

        elif platform == "darwin" or platform.startswith("linux"):
            self.db_name = "linDataBase.db"

            with sqlite3.connect("linDataBase.db") as db:
                cursor = db.cursor()
                cursor.executescript("""
                CREATE TABLE IF NOT EXISTS media_files (device_id TEXT, file_id TEXT, tag_index BIGINT);
                CREATE TABLE IF NOT EXISTS tag_indexes (tag_index BIGINT, tag TEXT, count BIGINT);
                """)
                db.commit()

        else:
            sys.exit("The platform is not supported")


    def window_resize(self, type_: str) -> None:
        """
        Функция автоматического изменения размера окна.

        :param type_: Переменная, отвечающая за вид изменения размера.
        """
        tab_index = self.ui.tabWidget.currentIndex()
        # Первый запуск программы
        if type_ == 'start':
            self.animation = QPropertyAnimation(self, b"size")
            self.animation.setDuration(500)
            self.animation.setEasingCurve(QEasingCurve.Linear)
            self.animation.setStartValue(QSize(20, 20))
            self.animation.setEndValue(QSize(500, 540))
            self.animation.start(QPropertyAnimation.DeleteWhenStopped)
        # Переключение между вкладками программы
        elif type_ == "change":
            # Проверка на несохраненные значения в окне настроек  
            if self.LastIndex == 1 and self.ui.pushButton_save_settings.isEnabled():
                error_message = QMessageBox()
                error_message.setWindowTitle('Изменение настроек')
                error_message.setWindowIcon(QIcon('icons/save_or_not.png'))
                error_message.setText("Вы хотите сохранить изменения?      ")
                error_message.setStandardButtons(QMessageBox.Yes | QMessageBox.No)

                result = error_message.exec_()

                if result == QMessageBox.Yes: # Изменить сохранение настроек на QSettings
                    self.save_settings()
                else:
                    self.ui.settings_init() #### Проверить!!!

        elif type_ == "left_window_opening": # Добавить зависимость от кол-ва фотографий в папке
            self.move_window(xy_shift=((application.size().width() - 600) // 2,
                                       (application.size().height() - 700) // 2),
                             new_size=(600, 700), type_="left_window_opening")

        elif type_ == "right_window_opening": # Добавить зависимость от кол-ва фотографий в папке
            self.move_window(xy_shift=((application.size().width() - 1250) // 2,
                                       (application.size().height() - 730) // 2),
                             new_size=(1250, 730), type_="right_window_opening")

        self.LastIndex = tab_index


    def move_window(self, xy_shift: tuple, new_size: tuple, type_: str) -> None:
        """
        Функция изменяет размер окна и одновременно перемещает его
        для избежания выхода за границы экрана.

        :param xy_shift: Кортеж со значениями, на которые нужно переместить окно.
        :param new_size: Кортеж с новым размером окна.
        :param type_: Строка, содержащая тип анимации.
        """
        new_coordinates = (application.geometry().x() + xy_shift[0],
                           application.geometry().y() + xy_shift[1])

        self.move_animation = QPropertyAnimation(self, b"geometry")
        self.move_animation.setDuration(1125)
        self.move_animation.setEasingCurve(QEasingCurve.OutCirc)
        self.move_animation.setStartValue(application.geometry())
        self.move_animation.setEndValue(QRect(new_coordinates[0], new_coordinates[1],
                                              new_size[0], new_size[1]))

        if type_ == "left_window_opening":
            self.move_animation.start()

        elif type_ == "right_window_opening":
            self.move_animation.start()
            self.move_animation.finished.connect(self.media_creating)


    def media_creating(self) -> None:
        """
        Функция добавляет pixmap к label в окне для просмотра увеличенных медиафайлов.
        """
        # File is photo
        if self.button_is_photo_mass[self.pressed_button_index]:
            pixmap = QPixmap(self.paths_to_all_files_list[self.pressed_button_index]).scaled(
                600, 400, aspectRatioMode=Qt.KeepAspectRatioByExpanding)
            self.right_window_label.setPixmap(pixmap)

            media_object = self.right_window_label
        # File is video
        else:
            file_way = self.paths_to_all_files_list[self.pressed_button_index]
            self.changing_video_size_and_position(file_way=file_way)

            self.media_player.setMedia(QMediaContent(QUrl.fromLocalFile(file_way)))
            self.media_player.play()
            self.media_player.pause()

            media_object = self.scene

        opacity_effect = QGraphicsOpacityEffect(media_object)
        media_object.setGraphicsEffect(opacity_effect)
        self.opacity_animation = QPropertyAnimation(opacity_effect, b"opacity")
        self.opacity_animation.setDuration(200)
        self.opacity_animation.setStartValue(0)
        self.opacity_animation.setEndValue(1)
        self.opacity_animation.start()
        self.opacity_animation.finished.connect(lambda: self.media_shadow_effect_init(media_object))


    def changing_video_size_and_position(self, file_way: str) -> None:
        """
        Функция высчитывает оптимальный размер для QVideoWidget и центрирует его.
        """
        image_size = cv2.VideoCapture(file_way)
        aspect_ratio = image_size.get(cv2.CAP_PROP_FRAME_HEIGHT) / image_size.get(cv2.CAP_PROP_FRAME_WIDTH)
        # 575 - Высота back_widget с учетом кнопок.
        # Horizontal orientation.
        if aspect_ratio < 1:
            width = 600 - 20
            height = int(ceil(width * aspect_ratio))
            self.video_widget.setMinimumSize(width, height)
            self.video_widget.move(300 - width // 2, ceil((575 - height) / 2))
        # Vertical orientation.
        else:
            height = 550
            width = int(ceil(height / aspect_ratio))
            self.video_widget.setMinimumSize(width, height)
            self.video_widget.move(300 - width // 2, ceil((575 - height) / 2))


    def media_shadow_effect_init(self, media_object: QWidget) -> None:
        self.shadow_effect_init(duration=200)
        media_object.setGraphicsEffect(self.shadow_effect)

        self.shadow_effect.rise_animation_start()


    def pushbutton_style_creator(self, pushbutton: QWidget) -> None:
        pushbutton.setStyleSheet("QPushButton {background-color: #c7c7c7; "
                                 "border-radius: 7px; border: 1px solid #8a8a8a}"
                                 "QPushButton::hover {background-color: #dedede;}"
                                 "QPushButton::pressed {background-color: #dadada;}")
        self.set_shadow_effect(object_=pushbutton)


    @staticmethod
    def set_shadow_effect(object_: QWidget) -> None:
        shadow = QGraphicsDropShadowEffect()
        shadow.setBlurRadius(4)
        shadow.setXOffset(0)
        shadow.setYOffset(0)
        object_.setGraphicsEffect(shadow)


# Установка иконки приложения для Windows
try:
    from PyQt5.QtWinExtras import QtWin
    myAppId = 'mycompany.myproduct.subproduct.version'
    QtWin.setCurrentProcessExplicitAppUserModelID(myAppId)
except ImportError:
    pass


if __name__ == '__main__':
    monitor_size = ()

    for monitor in get_monitors():
        if monitor.is_primary:
            monitor_size = (monitor.width, monitor.height)
    # Не найден ни один монитор
    if len(monitor_size) == 0:
        raise OSError

    app = QApplication([])
    app.setWindowIcon(QIcon("icons/WindowIcon.icns"))
    app.setStyle(QStyleFactory.keys()[-1])
    application = MMBody()
    application.move(monitor_size[0] // 2 - 250, monitor_size[1] // 2 - 270)
    application.setWindowIcon(QIcon("icons/WindowIcon.icns"))
    application.show()
    sys.exit(app.exec_())

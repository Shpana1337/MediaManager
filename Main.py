# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'newdesign.ui'
#
# Created by: PyQt5 UI code generator 5.15.7
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

import os
import sys
import array
import shutil
from PyQt5.QtMultimedia import QMediaPlayer, QMediaContent
from moviepy.editor import VideoFileClip
from PyQt5.QtCore import QUrl, QSize, Qt, QPropertyAnimation, QEasingCurve
from PyQt5.QtGui import QPixmap, QIcon
from PyQt5.QtWidgets import QHBoxLayout, QVBoxLayout, QListWidget, QPushButton, QLabel, \
    QMainWindow, QFileDialog, QLineEdit, QApplication, QStyleFactory, QScrollArea, QWidget, \
    QListWidgetItem, QGraphicsDropShadowEffect, QSpacerItem, QSizePolicy, QComboBox, QMessageBox
from collections import Counter
from pathlib import Path
import PyQt5.QtMultimediaWidgets
from PyQt5.QtMultimediaWidgets import QGraphicsVideoItem
from ui import Ui_MainWindow


class MM_body(QMainWindow):
    def __init__(self):
        super(MM_body, self).__init__()
        self.ui = Ui_MainWindow()
        self.ui.setupUi(self)
        self.setWindowTitle('МедиаМенеджер')

        #self.levels = 0
        #self.LastIndex = 0
        self.first_pressed_index = -1
        self.second_pressed_index = -1
        self.selection_type = 1
        self.previous_button_index = 0
        self.file_way_mass = []
        self.line_edits_mass = []
        self.list_widget_mass = []
        self.add_buttons_mass = []
        self.photo_button_mass = []
        self.delete_buttons_mass = []
        self.selected_files_mass = []
        self.button_is_photo_mass = []
        self.previous_elements_mass = []
        self.selected_files_way_mass = []
        self.frame_folder = Path('icons_cache')
        self.right_window_is_open = False

        self.button_stylesheet_settings = "QPushButton {background-color: #c7c7c7; border-radius: 7px; border: 1px solid #8a8a8a} " \
                                          "QPushButton::hover {background-color: #dedede; " \
                                          "QPushButton::pressed {background-color: #dadada;} " \
                                          "QToolTip {border: 1px solid black; background-color: white}"
        self.pushbutton_style_creator(self.ui.pushbutton_open_folder)
        self.window_resize('start')

        # Конфигурация чекбоксов
        # self.ui.checkBox_setting1.stateChanged.connect(self.check_box_func)
        # self.ui.checkBox_setting2.stateChanged.connect(self.check_box_func)
        # self.ui.checkBox_setting3.stateChanged.connect(self.check_box_func)
        # #

        # self.ToolTip_enable()
        # self.ui.tabWidget.currentChanged.connect(lambda: self.window_resize('change'))
        # self.ui.listWidget_history_all_categories.currentRowChanged.connect(self.listWidget_history_tags_creator)
        # self.ui.listWidget_history_tags.itemDoubleClicked.connect(self.add_tags_from_history)
        #
        # Конфигурация кнопок

        self.ui.pushbutton_open_folder.pressed.connect(self.open_folder)
        # self.ui.nextPageButton.pressed.connect(self.next_page)
        # self.ui.previousPageButton.pressed.connect(self.previous_page)
        # self.ui.pushButton_save_settings.pressed.connect(self.save_settings)
        # self.ui.pushButton_delete_settings.pressed.connect(self.ui.settings_init)
        # self.ui.pushButton_clean_all_files.pressed.connect(self.delete_all_files)
        #
        # self.ui.pushButton_open.pressed.connect(self.open_files)
        # self.ui.pushButton_load.pressed.connect(self.load_files)
        # self.ui.pushButton_delete_files.pressed.connect(self.PushButton_delete_files)


    def open_folder(self):
        '''
        :param counter: Счетчик фотографий
        :param frame_folder: Папка, в которую сохраняется первый кадр видео для создания иконки
        '''
        for file in self.frame_folder.iterdir():
            os.remove(file)

        dirlist = QFileDialog.getExistingDirectory(self,"Выбрать папку",".")
        path = Path(dirlist)
        self.layout_cleaner(self.ui.verticalLayout_11)

        self.counter = 0
        video_formats = ('mov', 'avi', 'mp4')
        photo_formats = ('jpg', 'jpeg', 'png')

        files_are_founded = False

        for file in path.iterdir():
            _file_name = file.name

            try:
                _file_type = (_file_name.split('.'))[-1]
            except: _file_type = ''

            if _file_type.lower() in photo_formats:
                files_are_founded = True
                self.block_creator(f'{dirlist}/{_file_name}', True)

            elif _file_type.lower() in video_formats:
                files_are_founded = True
                self.block_creator(f'{dirlist}/{_file_name}', False)

        if files_are_founded: self.upper_lower_layouts_creating()

        self.previous_elements_mass = self.all_tags_mass_creating()
        self.window_resize('left_window_opening')

        # present_tags = self.all_tags_mass_creating()
        # tag_founded_flag = False
        #
        # for el in present_tags:
        #     print(el)
        #     if el:
        #         tag_founded_flag = True
        #         break
        #
        # if tag_founded_flag:
        #     self.save_button.setEnabled(True)
        #     self.cancel_button.setEnabled(True)


    def tags_splitting(self, file_way):
        '''
        :return: Возвращаем массив с тегами, созданными по имени файла
        '''

        # Удаление пути файла, оставляем только поле с тегами
        file_way = file_way.split('{')
        file_way = file_way[-1]

        # Удаление формата файла в конце строки
        file_way = file_way.split('.')
        file_way = file_way[0]

        tags_mass = file_way.split(',')

        for i in range(len(tags_mass)):
            tags_mass[i] = tags_mass[i].strip()

        return tags_mass



    def block_creator(self, file_way, file_is_photo):
        '''
        :param ui.verticalLayout_11: Лэйаут скрол виджета
        :param horizontal_layout: Главный лэйаут блока
        :param vertical_layout: Правый лэйаут блока с лист виджетом и лэайутом с кнопками
        :param file_way: Путь к медиафайлу
        :param file_is_photo: Булева переменная, показывает является ли файл фотографией
        '''
        tags_mass = []

        # Сборка главного лэйаута блока
        horizontal_layout = QHBoxLayout()

        button_photo = QPushButton()
        button_photo.setMinimumSize(QSize(250, 170))

        # Проверка на то, что по файлу уже есть добавленные теги
        if '{' in file_way:
            tags_mass = self.tags_splitting(file_way)

        if file_is_photo:
            icon = file_way

            self.file_way_mass.append(file_way)
            self.button_is_photo_mass.append(True)

        else: # file is video
            # Сохраняем первый кадр видео для иконки в кнопку
            video = VideoFileClip(file_way)
            video.save_frame(f'{self.frame_folder}/{len(self.photo_button_mass)}.png', t = 1)
            #
            icon = f'{self.frame_folder}/{len(self.photo_button_mass)}.png'

            self.file_way_mass.append(file_way)
            self.button_is_photo_mass.append(False)


            # video_item = QGraphicsVideoItem()
            # video_item.setSize((QtCore.QSizeF(250,170)))
            #
            # scene = QtWidgets.QGraphicsScene(self)
            # scene.addItem(video_item)
            # graphicsView = QtWidgets.QGraphicsView(scene)
            # graphicsView.setMinimumSize(QtCore.QSize(250,170))
            # layout = QtWidgets.QVBoxLayout()
            # layout.addWidget(graphicsView)
            # self.setLayout(layout)
            # self.media_player = QMediaPlayer(None, QMediaPlayer.VideoSurface)
            # self.media_player.setVideoOutput(video_item)
            # self.media_player.setMedia(QMediaContent(QUrl.fromLocalFile(file_way)))
            #
            # self.media_player.play()
            # self.media_player.stop()
            #
            # horizontal_layout.addLayout(layout)

        button_photo.setIcon(QIcon(icon))
        button_photo.setIconSize(QSize(220, 160))
        button_photo.setStyleSheet("QPushButton {background-color: white;border-radius: 7px; border: 1px solid #8a8a8a}"
                                                "QPushButton::hover {background-color: #eaeaea;}"
                                                "QPushButton::pressed {background-color: #dadada;}")
        self.setShadowEffect(button_photo)

        horizontal_layout.addWidget(button_photo)
        self.photo_button_mass.append(button_photo)

        pressed_button_index = self.photo_button_mass.index(button_photo)
        button_photo.pressed.connect(lambda: self.right_window_changing(pressed_button_index))

        ## Сборка правого лэйаута
        vertical_layout = QVBoxLayout()

        list_widget = QListWidget()
        self.setShadowEffect(list_widget)

        if tags_mass: # Если к этой фотографии уже добавлены теги
            for i in range(len(tags_mass)):
                item = QListWidgetItem(tags_mass[i])
                list_widget.addItem(item)

        button_delete_tag = QPushButton()
        button_delete_tag.setText('-')
        self.pushbutton_style_creator(button_delete_tag)
        button_delete_tag.setMinimumSize(50,25)

        ### Сборка лэйаута для line edit и кнопки
        horizontal_layout_for_line_edit = QHBoxLayout()

        button_add_tag = QPushButton()
        button_add_tag.setText('+')

        self.pushbutton_style_creator(button_add_tag)
        button_add_tag.setMinimumSize(65,25)

        line_edit = QLineEdit()
        line_edit.setPlaceholderText('Введите тег:')
        line_edit.setStyleSheet("QLineEdit {border-radius: 7px; border: 1px solid #8a8a8a;}")
        line_edit.setMinimumSize(70,25)
        self.setShadowEffect(line_edit)

        horizontal_layout_for_line_edit.addWidget(line_edit)
        horizontal_layout_for_line_edit.addWidget(button_add_tag)
        ###

        vertical_layout.addWidget(list_widget)
        vertical_layout.addWidget(button_delete_tag)
        vertical_layout.addLayout(horizontal_layout_for_line_edit)
        ##

        horizontal_layout.addLayout(vertical_layout)
        #

        self.ui.verticalLayout_11.addLayout(horizontal_layout)

        self.line_edits_mass.append(line_edit)
        self.list_widget_mass.append(list_widget)
        self.add_buttons_mass.append(button_add_tag)
        self.delete_buttons_mass.append(button_delete_tag)

        pressed_button_index = self.add_buttons_mass.index(button_add_tag)

        button_add_tag.pressed.connect(lambda: self.add_tag(pressed_button_index))
        button_delete_tag.pressed.connect(lambda: self.delete_tag(pressed_button_index))



    def selection_type_change(self, value):
        self.selection_type = value + 1
        self.right_block_cleaner()



    def upper_lower_layouts_creating(self):
        # Верхний лэйаут
        combo_box = QComboBox()
        combo_box.setMinimumSize(65,25)
        combo_box.addItem('Одиночное выделение')
        combo_box.addItem('Выделение "от и до"')
        combo_box.addItem('Выборочное выделение')
        combo_box.currentIndexChanged.connect(self.selection_type_change)

        button_cancel_selection = QPushButton()
        button_cancel_selection.setText('Отменить выделение')
        button_cancel_selection.setMinimumSize(65, 25)
        button_cancel_selection.setMaximumSize(600,25)
        button_cancel_selection.setEnabled(False)
        button_cancel_selection.pressed.connect(self.right_block_cleaner)
        self.button_cancel_selection = button_cancel_selection
        self.pushbutton_style_creator(button_cancel_selection)

        self.ui.upperbuttons_horizontal_layout.addWidget(combo_box)
        self.ui.upperbuttons_horizontal_layout.addWidget(button_cancel_selection)

        # Нижний лэйаут
        save_button = QPushButton()
        save_button.setText('Сохранить изменения')
        save_button.setMinimumSize(65,25)
        save_button.setEnabled(False)
        save_button.pressed.connect(self.save_tags)
        self.save_button = save_button
        self.pushbutton_style_creator(save_button)

        cancel_button = QPushButton()
        cancel_button.setText('Отменить изменения')
        cancel_button.setMinimumSize(65, 25)
        cancel_button.setEnabled(False)
        self.cancel_button = cancel_button
        self.pushbutton_style_creator(cancel_button)

        self.ui.lowerbuttons_horizontal_layout.addWidget(save_button)
        self.ui.lowerbuttons_horizontal_layout.addWidget(cancel_button)



    def save_tags(self):

        present_tags = self.all_tags_mass_creating()

        for i in range(len(self.previous_elements_mass)):
            previous_block_tags = self.previous_elements_mass[i]
            present_block_tags = present_tags[i]

            # Нашли измененный блок
            if previous_block_tags != present_block_tags:
                pass



    def right_block_cleaner(self):
        self.layout_cleaner(self.ui.verticalLayout_right_window)
        self.button_cancel_selection.setEnabled(False)
        self.right_window_is_open = False
        self.first_pressed_index = -1
        self.second_pressed_index = -1

        for _ in range(len(self.selected_files_mass)):
            self.selected_files_mass[_].setStyleSheet(
                "QPushButton {background-color: white; border-radius: 7px; border: 1px solid #8a8a8a}"
                "QPushButton::hover {background-color: #dedede;}"
                "QPushButton::pressed {background-color: #dadada;}")

        self.selected_files_mass = []
        self.selected_files_way_mass = []

        self.window_resize('left_window_opening')

        # self.photo_button_mass[self.previous_button_index].setStyleSheet(
        #     "QPushButton {background-color: white; border-radius: 7px; border: 1px solid #8a8a8a}"
        #     "QPushButton::hover {background-color: #dedede;}"
        #     "QPushButton::pressed {background-color: #dadada;}")



    def right_window_creating(self, pressed_button_index):
        if self.right_block_create_test(pressed_button_index):
            print(f'Ready to create a block! Selection_type = {self.selection_type}')
            self.window_resize('right_window_opening')
            if self.button_is_photo_mass[pressed_button_index]: # Создание блока с фотографией
                back_widget = QWidget()
                back_widget.setMinimumSize(600,600)
                back_widget.setMaximumSize(600,700)
                back_widget.setStyleSheet('QWidget {background-color: #f0f0f0; border: 1px solid #b9b9b9;}')

                local_vertical_layout = QVBoxLayout(back_widget)

                label = QLabel()
                label.setMaximumSize(700,500)
                shadow = QGraphicsDropShadowEffect()
                shadow.setBlurRadius(20)
                shadow.setYOffset(0)
                shadow.setXOffset(0)
                label.setGraphicsEffect(shadow)
                pixmap = QPixmap(self.file_way_mass[pressed_button_index]).scaled(600, 400, aspectRatioMode=Qt.KeepAspectRatioByExpanding)
                label.setPixmap(pixmap)
                self.right_window_label = label

                spacer = QSpacerItem(1, 1, QSizePolicy.Expanding, QSizePolicy.Expanding)
                local_vertical_layout.addItem(spacer)
                local_vertical_layout.addWidget(label)

                spacer = QSpacerItem(1, 1, QSizePolicy.Expanding, QSizePolicy.Expanding)
                local_vertical_layout.addItem(spacer)

                horizontal_buttons_layout = QHBoxLayout()

                left_arrow = QPushButton()
                left_arrow.setText('<<')
                left_arrow.setMinimumSize(65,25)
                self.left_arrow = left_arrow
                self.pushbutton_style_creator(left_arrow)
                left_arrow.pressed.connect(lambda: self.arrow_button_pressed('left'))

                right_arrow = QPushButton()
                right_arrow.setText('>>')
                right_arrow.setMinimumSize(65,25)
                self.right_arrow = right_arrow
                self.pushbutton_style_creator(right_arrow)
                right_arrow.pressed.connect(lambda: self.arrow_button_pressed('right'))

                self.previous_button_index = pressed_button_index

                if pressed_button_index == 0:
                    left_arrow.setEnabled(False)

                elif pressed_button_index == len(self.photo_button_mass) - 1:
                    right_arrow.setEnabled(False)

                horizontal_buttons_layout.addWidget(left_arrow)
                horizontal_buttons_layout.addWidget(right_arrow)
                local_vertical_layout.addLayout(horizontal_buttons_layout)
                self.ui.verticalLayout_right_window.addWidget(back_widget)
            
            else: pass # Создание блока с видео 

            self.right_window_is_open = True
            self.button_cancel_selection.setEnabled(True)



    def right_window_changing(self, pressed_button_index):
        '''
        :param self.previous_button_index: индекс предпоследней нажатой кнопки
        :param selection_type: способ выделения фотографий (1 - одиночное, 2 - от и до, 3 - выборочное)
        :param selected_photo_mass: массив с указателями на кнопки выбранных фотографий
        :param ready_to_create_block: флаг = True, когда выполнятся все условия для открытия блока
                                      для одного из вариантов выделения

        Второй тип выделения:
        :param first_pressed_index: индекс первого нажатого элемента
        :param second_pressed_index: индекс второго нажатого элемента
        '''
        if not(self.right_window_is_open):
            self.right_window_creating(pressed_button_index)
            return
        
        if self.selection_type == 1:
            if self.button_is_photo_mass[pressed_button_index]: # Если выбрана фотография 
                self.photo_button_mass[self.previous_button_index].setStyleSheet(
                    "QPushButton {background-color: white; border-radius: 7px; border: 1px solid #8a8a8a}"
                    "QPushButton::hover {background-color: #dedede;}"
                    "QPushButton::pressed {background-color: #dadada;}")
                
                self.photo_button_mass[pressed_button_index].setStyleSheet(
                    "QPushButton {background-color: #dadada; border-radius: 7px; border: 1px solid #8a8a8a}"
                    "QPushButton::hover {background-color: #dedede;}"
                    "QPushButton::pressed {background-color: #dadada;}")

                pixmap = QPixmap(self.file_way_mass[pressed_button_index]).scaled(600, 400, aspectRatioMode=Qt.KeepAspectRatioByExpanding)
                self.right_window_label.setPixmap(pixmap)

                self.previous_button_index = pressed_button_index
                
                if pressed_button_index == 0:
                    self.left_arrow.setEnabled(False)
                    self.right_arrow.setEnabled(True)
                elif pressed_button_index == len(self.file_way_mass) - 1:
                    self.right_arrow.setEnabled(False)
                    self.left_arrow.setEnabled(True)
                else: 
                    self.left_arrow.setEnabled(True)
                    self.right_arrow.setEnabled(True)

            else: # Если выбрано видео
                pass

        elif self.selection_type == 2: pass
        else: pass

        self.button_cancel_selection.setEnabled(True)



    def right_block_create_test(self, pressed_button_index):
        '''
        Фунция проверяет, выполнены ли все условия для создания расширенного окна с медиафайлами
        '''
        if self.selection_type == 1: # Одиночное выделение 
            self.photo_button_mass[pressed_button_index].setStyleSheet(
                "QPushButton {background-color: #dadada; border-radius: 7px; border: 1px solid #8a8a8a}"
                "QPushButton::hover {background-color: #dedede;}"
                "QPushButton::pressed {background-color: #dadada;}")
            
            self.selected_files_mass = [self.photo_button_mass[pressed_button_index]]
            self.selected_files_way_mass = [self.file_way_mass[pressed_button_index]] 
            return True

        elif self.selection_type == 2: # Выделение "от и до"
            return self.from_to_selection(pressed_button_index)

        else: # Выборочное выделение 
            return self.selective_selection(pressed_button_index)



    def from_to_selection(self, pressed_button_index):
        if self.first_pressed_index == -1: # Указание начала промежутка
            self.first_pressed_index = pressed_button_index
            self.photo_button_mass[pressed_button_index].setStyleSheet(
                    "QPushButton {background-color: #dadada; border-radius: 7px; border: 1px solid #8a8a8a}"
                    "QPushButton::hover {background-color: #dedede;}"
                    "QPushButton::pressed {background-color: #dadada;}")

        elif self.second_pressed_index == -1: # Указание конца промежутка 
            self.second_pressed_index = pressed_button_index

            # Если изначально был выбран конец промежутка, а не начало
            if self.first_pressed_index > self.second_pressed_index:
                self.first_pressed_index, self.second_pressed_index = self.second_pressed_index, self.first_pressed_index

            for i in range(self.first_pressed_index + 1, self.second_pressed_index + 1):
                self.photo_button_mass[i].setStyleSheet(
                    "QPushButton {background-color: #dadada; border-radius: 7px; border: 1px solid #8a8a8a}"
                    "QPushButton::hover {background-color: #dedede;}"
                    "QPushButton::pressed {background-color: #dadada;}")
                
            self.selected_files_mass = self.photo_button_mass[self.first_pressed_index:self.second_pressed_index + 1]
            self.selected_files_way_mass = self.file_way_mass[self.first_pressed_index:self.second_pressed_index + 1] 

            return #True

        else: # Уже выбран промежуток (изменение промежутка)
            # Изменение начала промежутка
            if pressed_button_index < self.first_pressed_index:
                for i in range(pressed_button_index, self.first_pressed_index):
                    self.photo_button_mass[i].setStyleSheet(
                            "QPushButton {background-color: #dadada; border-radius: 7px; border: 1px solid #8a8a8a}"
                            "QPushButton::hover {background-color: #dedede;}"
                            "QPushButton::pressed {background-color: #dadada;}")
                    
                self.first_pressed_index = pressed_button_index

            # Изменение конца промежутка
            elif pressed_button_index > self.second_pressed_index:
                for i in range(self.second_pressed_index + 1, pressed_button_index):
                    self.photo_button_mass[i].setStyleSheet(
                        "QPushButton {background-color: #dadada; border-radius: 7px; border: 1px solid #8a8a8a}"
                        "QPushButton::hover {background-color: #dedede;}"
                        "QPushButton::pressed {background-color: #dadada;}")

                self.second_pressed_index = pressed_button_index

            # Обрезание промежутка (выбрана кнопка из диапазона)
            elif pressed_button_index > self.first_pressed_index and pressed_button_index < self.second_pressed_index:
                # Обрезаем начало (расстояние от начала до выбранного индекса наименьшее)
                if (pressed_button_index - self.first_pressed_index) < (self.second_pressed_index - pressed_button_index):
                    for i in range(self.first_pressed_index, pressed_button_index):
                        self.photo_button_mass[i].setStyleSheet(
                                "QPushButton {background-color: white; border-radius: 7px; border: 1px solid #8a8a8a}"
                                "QPushButton::hover {background-color: #dedede;}"
                                "QPushButton::pressed {background-color: #dadada;}")
                    
                    self.first_pressed_index = pressed_button_index
                
                else: # Обрезаем конец
                    for i in range(pressed_button_index + 1, self.second_pressed_index + 1):
                        self.photo_button_mass[i].setStyleSheet(
                                "QPushButton {background-color: white; border-radius: 7px; border: 1px solid #8a8a8a}"
                                "QPushButton::hover {background-color: #dedede;}"
                                "QPushButton::pressed {background-color: #dadada;}")

                    self.second_pressed_index = pressed_button_index

            self.selected_files_mass = self.photo_button_mass[self.first_pressed_index:self.second_pressed_index + 1]
            self.selected_files_way_mass = self.file_way_mass[self.first_pressed_index:self.second_pressed_index + 1] 

            return #True
        return 


    def selective_selection(self, pressed_button_index):
        '''
        :return: Возвращаем True, если выполнены все условия для открытия right_block 
        '''

        if self.file_way_mass[pressed_button_index] in self.selected_files_way_mass:
            self.photo_button_mass[pressed_button_index].setStyleSheet(
                "QPushButton {background-color: white; border-radius: 7px; border: 1px solid #8a8a8a}"
                "QPushButton::hover {background-color: #dedede;}"
                "QPushButton::pressed {background-color: #dadada;}")
            
            self.selected_files_way_mass.pop(pressed_button_index)
            self.selected_files_mass.pop(pressed_button_index)

        else:
            self.selected_files_way_mass.append(self.file_way_mass[pressed_button_index])
            self.selected_files_mass.append(self.photo_button_mass[pressed_button_index])

            self.photo_button_mass[pressed_button_index].setStyleSheet(
                    "QPushButton {background-color: #dadada; border-radius: 7px; border: 1px solid #8a8a8a}"
                    "QPushButton::hover {background-color: #dedede;}"
                    "QPushButton::pressed {background-color: #dadada;}")

        if len(self.selected_files_mass) > 1:
            return #True
        
        else:
            self.button_cancel_selection.setEnabled(False) 
            return 
        


    def arrow_button_pressed(self, side):
        '''
        Функция перелистывания медиафайлов в right_block 

        :param side: Переменная, обозначающая сторону, в которую будет выполняться перелистывание
        '''

        if self.selection_type == 1:
            if side == 'left':
                self.photo_button_mass[self.previous_button_index].setStyleSheet(
                            "QPushButton {background-color: white; border-radius: 7px; border: 1px solid #8a8a8a}"
                            "QPushButton::hover {background-color: #dedede;}"
                            "QPushButton::pressed {background-color: #dadada;}")

                self.photo_button_mass[self.previous_button_index - 1].setStyleSheet(
                            "QPushButton {background-color: #dadada; border-radius: 7px; border: 1px solid #8a8a8a}"
                            "QPushButton::hover {background-color: #dedede;}"
                            "QPushButton::pressed {background-color: #dadada;}")

                icon_way = self.file_way_mass[self.previous_button_index - 1]
                self.selected_files_mass = [self.photo_button_mass[self.previous_button_index - 1]]
                self.selected_files_way_mass = [self.file_way_mass[self.previous_button_index - 1]]
                self.previous_button_index -= 1

                pixmap = QPixmap(icon_way).scaled(600, 400, aspectRatioMode=Qt.KeepAspectRatioByExpanding)
                self.right_window_label.setPixmap(pixmap)

                if self.previous_button_index == 0: 
                    self.left_arrow.setEnabled(False)

                if not(self.right_arrow.isEnabled()):
                    self.right_arrow.setEnabled(True)

            else: # right
                self.photo_button_mass[self.previous_button_index].setStyleSheet(
                            "QPushButton {background-color: white; border-radius: 7px; border: 1px solid #8a8a8a}"
                            "QPushButton::hover {background-color: #dedede;}"
                            "QPushButton::pressed {background-color: #dadada;}")

                self.photo_button_mass[self.previous_button_index + 1].setStyleSheet(
                            "QPushButton {background-color: #dadada; border-radius: 7px; border: 1px solid #8a8a8a}"
                            "QPushButton::hover {background-color: #dedede;}"
                            "QPushButton::pressed {background-color: #dadada;}")

                self.selected_files_mass = [self.photo_button_mass[self.previous_button_index + 1]]
                self.selected_files_way_mass = [self.file_way_mass[self.previous_button_index + 1]]
                icon_way = self.file_way_mass[self.previous_button_index + 1]
                self.previous_button_index += 1

                pixmap = QPixmap(icon_way).scaled(600, 400, aspectRatioMode=Qt.KeepAspectRatioByExpanding)
                self.right_window_label.setPixmap(pixmap)

                if self.previous_button_index == len(self.photo_button_mass) - 1:
                    self.right_arrow.setEnabled(False)

                if not(self.left_arrow.isEnabled()):
                    self.left_arrow.setEnabled(True)



    def add_tag(self, index):
        if index != -1: # Нажатие на кнопку +
            line_edit_text = self.line_edits_mass[index].text()
            if line_edit_text:

                already_exist_tags = []

                for i in range(self.list_widget_mass[index].count()):
                    already_exist_tags.append(self.list_widget_mass[index].item(i).text().lower())

                line_edit_text = line_edit_text.split(',')
                line_edit_text = list(set(line_edit_text))

                if already_exist_tags:
                    for tag in line_edit_text:
                        tag = tag.strip()
                        if tag != ' ' and tag != '' and tag.lower() not in already_exist_tags:
                            self.list_widget_mass[index].addItem(tag)

                else:
                    for tag in line_edit_text:
                        tag = tag.strip()
                        if tag != ' ' and tag != '':
                            self.list_widget_mass[index].addItem(tag)

                self.line_edits_mass[index].clear()

        else: # Функция вызвана нажатием кнопки Enter

            for i in range(len(self.line_edits_mass)):
                if self.line_edits_mass[i].text() != '':
                    self.add_tag(i)

            return

        self.previous_and_present_tags_equal_test()



    def delete_tag(self, index):
        a = self.list_widget_mass[index].selectedIndexes()

        _selected_index = self.list_widget_mass[index].count() - 1
        _items_mass = []

        for i in a: _selected_index = i.row()

        # Очистка и обратное заполнение listWidget
        for i in range(self.list_widget_mass[index].count()):
            if i != _selected_index:
                item = self.list_widget_mass[index].item(i)
                name = item.text()
                foreground = item.foreground()
                _items_mass.append([name, foreground])

        self.list_widget_mass[index].clear()

        for i in range(len(_items_mass)):
            newItem = QListWidgetItem()
            newItem.setText(_items_mass[i][0])
            newItem.setForeground(_items_mass[i][1])
            self.list_widget_mass[index].addItem(newItem)

        self.previous_and_present_tags_equal_test()



    def previous_and_present_tags_equal_test(self):
        present_tags = self.all_tags_mass_creating()
        is_equal = True

        for i in range(len(self.previous_elements_mass)):
            # Проверка на содержание одинаковых элементов
            if Counter(present_tags[i]) != Counter(self.previous_elements_mass[i]):
                if not self.save_button.isEnabled():
                    self.save_button.setEnabled(True)
                    self.cancel_button.setEnabled(True)
                is_equal = False
                break

        if is_equal:
            self.save_button.setEnabled(False)
            self.cancel_button.setEnabled(False)



    def all_tags_mass_creating(self):
        all_tags_mass = []
        for i in range(len(self.list_widget_mass)):
            _mass = []
            if self.list_widget_mass[i].count() != 0:
                for j in range(self.list_widget_mass[i].count()):
                    _mass.append(self.list_widget_mass[i].item(j).text())

            # добавляем в двумерный массив либо пустые массивы, если в лв нет тегов, либо массив с эл-тами лв
            all_tags_mass.append(_mass)
        return all_tags_mass



    def layout_cleaner(self, layout):
        if layout is not None:
            while layout.count():
                item = layout.takeAt(0)
                widget = item.widget()

                if widget is not None:
                    widget.setParent(None)
                else:
                    self.layout_cleaner(item.layout())



    # def ToolTip_enable(self, duration = 1):
        # if self.ui.checkBox_setting1.isChecked():
        #     duration = 5000
        #
        # for button in self.ui.pushButton_input_mass:
        #     button.setToolTipDuration(duration)
        # for button in self.ui.pushButton_category_delete_mass:
        #     button.setToolTipDuration(duration)
        # for button in self.ui.pushButton_categories_color_mass:
        #     button.setToolTipDuration(duration)
        # for button in self.ui.pushButton_category_change_priority_mass:
        #     button.setToolTipDuration(duration)
        # self.ui.pushButton_addcategory.setToolTipDuration(duration)
        # self.ui.listWidget_history_tags.setToolTipDuration(duration)
        # self.ui.pushButton_deletecategory.setToolTipDuration(duration)



    # Добавление тегов
    # def add_tags(self, called_by):
    #
    #     if called_by != -1: # Нажатие на кнопку
    #         if self.ui.lineEdit_tags_mass[called_by].text() != '':
    #             tags_mass = []
    #
    #             # Добавление тегов, написанных через запятую
    #             if ',' in self.ui.lineEdit_tags_mass[called_by].text():
    #                 tags_mass = self.ui.lineEdit_tags_mass[called_by].text().split(',')
    #             else: tags_mass.append(self.ui.lineEdit_tags_mass[called_by].text())
    #             #
    #             tags_mass = list(set(tags_mass))
    #
    #             for i in range(tags_mass.count('')): tags_mass.pop(tags_mass.index('')) # Удаление пустых тэгов из массива
    #
    #             if len(tags_mass) != 0:
    #
    #                 for i in range(len(tags_mass)):
    #                     tags_mass[i] = tags_mass[i].strip()
    #                     item = QtWidgets.QListWidgetItem()
    #                     item.setText(tags_mass[i][0].upper() + tags_mass[i][1:])
    #
    #                     if self.category_colors_mass[called_by] == 0:
    #                         item.setForeground(QtGui.QColor('green'))
    #                         self.tags_priority[called_by].append(0)
    #                     else:
    #                         item.setForeground(QtGui.QColor('blue'))
    #                         self.tags_priority[called_by].append(1)
    #
    #                     self.ui.listWidget_mass[called_by].addItem(item)
    #
    #
    #                 self.ui.pushButton_load.setEnabled(True)
    #                 self.ui.pushButton_open.setEnabled(True)
    #                 self.ui.pushButton_delete_files.setEnabled(True)
    #                 self.ui.pushButton_category_delete_mass[called_by].setEnabled(True)
    #                 self.ui.pushButton_category_change_priority_mass[called_by].setEnabled(True)
    #                 if not(self.ui.pushButton_categories_color_mass[called_by].isEnabled()):
    #                     self.ui.pushButton_categories_color_mass[called_by].setEnabled(True)
    #                     self.ui.pushButton_categories_color_mass[called_by].setStyleSheet("QPushButton {"
    #                                                                               "background-color: #3CFF00; border-radius: 7px; border: 1px solid #8a8a8a}"
    #                                                                               "QPushButton::hover {background-color: #83FF5C;}")
    #
    #
    #             self.ui.lineEdit_tags_mass[called_by].clear()
    #
    #     else:  # Нажатие на Enter
    #         for i in range(len(self.ui.lineEdit_tags_mass)):
    #             if self.ui.lineEdit_tags_mass[i].text() != '':
    #                 tags_mass = []
    #
    #                 # Добавление тегов, написанных через запятую
    #                 if ',' in self.ui.lineEdit_tags_mass[i].text():
    #                     tags_mass = self.ui.lineEdit_tags_mass[i].text().split(',')
    #                 else:
    #                     tags_mass.append(self.ui.lineEdit_tags_mass[i].text())
    #                 #
    #                 tags_mass = list(set(tags_mass))
    #
    #                 for j in range(tags_mass.count('')): tags_mass.pop(tags_mass.index(''))  # Удаление пустых тэгов из массива
    #                 for j in range(tags_mass.count(' ')): tags_mass.pop(tags_mass.index(' '))
    #
    #                 for _ in range(self.ui.listWidget_mass[i].count()): # Удаление уже существующих тегов
    #                     _tag = self.ui.listWidget_mass[i].item(_).text().lower()
    #                     if _tag in tags_mass: del tags_mass[tags_mass.index(_tag)]
    #
    #
    #                 if len(tags_mass) != 0:
    #                     for j in range(len(tags_mass)):
    #                         tags_mass[j] = tags_mass[j].strip()
    #                         item = QtWidgets.QListWidgetItem()
    #                         item.setText(tags_mass[j][0].upper() + tags_mass[j][1:])
    #                         self.ui.listWidget_mass[i].addItem(item)
    #
    #                         if not(self.ui.pushButton_categories_color_mass[i].isEnabled()):
    #                             self.ui.pushButton_categories_color_mass[i].setEnabled(True)
    #                             self.ui.pushButton_categories_color_mass[i].setStyleSheet("QPushButton {"
    #                                                                                       "background-color: #3CFF00; border-radius: 7px; border: 1px solid #8a8a8a}"
    #                                                                                       "QPushButton::hover {background-color: #83FF5C;}")
    #                             item.setForeground(QtGui.QColor('green'))
    #                             self.tags_priority[i].append(0)
    #
    #                         else:
    #                             if self.category_colors_mass[i] == 0:
    #                                 item.setForeground(QtGui.QColor('green'))
    #                                 self.tags_priority[i].append(0)
    #                             else:
    #                                 item.setForeground(QtGui.QColor('blue'))
    #                                 self.tags_priority[i].append(1)
    #
    #                         self.ui.pushButton_category_change_priority_mass[i].setEnabled(True)
    #
    #                     self.ui.pushButton_load.setEnabled(True)
    #                     self.ui.pushButton_open.setEnabled(True)
    #                     self.ui.pushButton_delete_files.setEnabled(True)
    #                     self.ui.pushButton_category_delete_mass[i].setEnabled(True)
    #
    #
    #                 self.ui.lineEdit_tags_mass[i].clear()


    # # Удаление тегов
    # def delete_tags(self, called_by, _lw_count_flag=True):
    #     a = self.ui.listWidget_mass[called_by].selectedIndexes()
    #
    #     _selected_index = self.ui.listWidget_mass[called_by].count() - 1
    #     _items_mass = []
    #
    #     for i in a: _selected_index = i.row()
    #
    #     # Очистка и обратное заполнение listWidget
    #     for i in range(self.ui.listWidget_mass[called_by].count()):
    #         if i != _selected_index:
    #             item = self.ui.listWidget_mass[called_by].item(i)
    #             name = item.text()
    #             foreground = item.foreground()
    #             _items_mass.append([name, foreground])
    #
    #     self.ui.listWidget_mass[called_by].clear()
    #
    #     for i in range(len(_items_mass)):
    #         newItem = QtWidgets.QListWidgetItem()
    #         newItem.setText(_items_mass[i][0])
    #         newItem.setForeground(_items_mass[i][1])
    #         self.ui.listWidget_mass[called_by].addItem(newItem)
    #     #
    #
    #
    #     if self.ui.listWidget_mass[called_by].count() == 0:
    #         self.category_colors_mass[called_by] = 0
    #         self.ui.pushButton_category_delete_mass[called_by].setEnabled(False)
    #         self.ui.pushButton_categories_color_mass[called_by].setEnabled(False)
    #         self.ui.pushButton_category_change_priority_mass[called_by].setEnabled(False)
    #         self.ui.pushButton_category_change_priority_mass[called_by].setIcon(QtGui.QIcon("icons/gr.png"))
    #         self.ui.pushButton_categories_color_mass[called_by].setStyleSheet("QPushButton {"
    #                                                                "background-color: #c7c7c7; border-radius: 7px; border: 1px solid #8a8a8a}"
    #                                                                "QPushButton::hover {background-color: #dedede;}")
    #
    #         # Проверка на пустоту всех лист виджетов
    #         for j in range(len(self.ui.listWidget_mass)):
    #             if j != called_by:
    #                 if self.ui.listWidget_mass[j].count() != 0:
    #                     _lw_count_flag = False
    #
    #         if _lw_count_flag == True:
    #
    #             self.ui.pushButton_load.setEnabled(False)
    #             self.ui.pushButton_open.setEnabled(False)
    #             self.ui.pushButton_delete_files.setEnabled(False)
    #
    #
    # # Добавление категорий на странице "Категории тегов"
    # def add_category(self):
    #     if self.ui.lineEdit_category.text() != '':
    #
    #         tags_mass = []
    #         mass = [self.ui.listWidget_categories.item(row).text().lower() for row in
    #                 range(self.ui.listWidget_categories.count())]  # Получение элементов в listWidget
    #
    #         self.previous_categories = mass
    #
    #         # Добавление тегов, написанных через запятую
    #         if ',' in self.ui.lineEdit_category.text():
    #             tags_mass = self.ui.lineEdit_category.text().split(',')
    #         else:
    #             tags_mass.append(self.ui.lineEdit_category.text())
    #         #
    #         tags_mass = list(set(tags_mass))
    #
    #         for i in range(tags_mass.count('')): tags_mass.pop(tags_mass.index(''))  # Удаление пустых тэгов из массива
    #
    #         if self.ui.listWidget_categories.count() + len(tags_mass) <= 8:
    #
    #             self.ui.listWidget_categories.clear()
    #
    #             if len(tags_mass) != 0:
    #
    #                 for i in range(len(tags_mass)): # Добавление новых тегов
    #                     tags_mass[i] = tags_mass[i].strip()
    #                     if tags_mass[i].lower() not in mass:
    #                         item = QtWidgets.QListWidgetItem()
    #                         item.setText(tags_mass[i][0].upper() + tags_mass[i][1:])
    #                         self.ui.listWidget_categories.addItem(item)
    #
    #                 for i in range(len(mass)): # Добавление старых тегов
    #                     item = QtWidgets.QListWidgetItem()
    #                     item.setText(mass[i][0].upper() + mass[i][1:])
    #                     self.ui.listWidget_categories.addItem(item)
    #
    #                 self.ui.pushButton_save_changes.setEnabled(True)
    #                 self.ui.pushButton_cancel_changes.setEnabled(True)
    #                 self.ui.pushButton_deletecategory.setEnabled(True)
    #
    #
    #
    #
    #         else:  # Вывод ошибки
    #             error_message = QtWidgets.QMessageBox()
    #             error_message.setWindowTitle('Ошибка!')
    #             error_message.setText("Невозможно добавить больше 8 категорий")
    #             error_message.setWindowIcon(QtGui.QIcon('icons/remove.png'))
    #             error_message.setDefaultButton(QtWidgets.QMessageBox.Yes)
    #
    #             error_message.exec_()
    #
    #         self.ui.lineEdit_category.clear()
    #
    #     mass = [self.ui.listWidget_categories.item(row).text().lower() for row in
    #             range(self.ui.listWidget_categories.count())]  # Получение элементов в listWidget
    #
    #     if mass == self.ui.categories_mass:  # Все исходные категории сохранились
    #         self.ui.pushButton_save_changes.setEnabled(False)
    #         self.ui.pushButton_cancel_changes.setEnabled(False)



    # # Удаление категорий на странице "Категории тегов"
    # def delete_category(self): #flag = False
    #     print(self.ui.categories_mass)
    #     a = self.ui.listWidget_categories.selectedIndexes()
    #
    #     if not(a):
    #         self.ui.listWidget_categories.takeItem(0)
    #
    #     else:
    #         for i in a: self.ui.listWidget_categories.takeItem(i.row())
    #
    #     # for i in a:
    #     #     _category = (self.ui.listWidget_categories.item(i.row()).text().lower())
    #     #
    #     #     if _category in self.ui.white_history_categories:
    #     #         _index = self.ui.white_history_categories.index(_category)
    #     #
    #     #         self.ui.grey_history_categories.append(_category)
    #     #         self.ui.grey_history_tags.append(self.ui.white_history_tags[_index])
    #     #
    #     #         self.ui.white_history_categories = self.ui.white_history_categories[:_index] + self.ui.white_history_categories[_index+1:]
    #     #         self.ui.white_history_tags = self.ui.white_history_tags[:_index] + self.ui.white_history_tags[_index+1:]
    #     #
    #     #         self.ui.listWidget_categories.takeItem(i.row())
    #     #         flag = True
    #
    #
    #     # if flag == False:
    #     #     _category = (self.ui.listWidget_categories.item(self.ui.listWidget_categories.count() - 1).text().lower())
    #     #     _index = self.ui.listWidget_categories.count() - 1
    #     #
    #     #     self.ui.listWidget_categories.takeItem(self.ui.listWidget_categories.count() - 1)
    #
    #     if self.ui.listWidget_categories.count() == 0:
    #         self.ui.pushButton_deletecategory.setEnabled(False)
    #
    #     mass = [self.ui.listWidget_categories.item(row).text().lower() for row in
    #             range(self.ui.listWidget_categories.count())]  # Получение элементов в listWidget
    #
    #     # Все исходные категории сохранились
    #     if mass == self.ui.categories_mass: self.ui.pushButton_save_changes.setEnabled(False), \
    #                                         self.ui.pushButton_cancel_changes.setEnabled(False)
    #
    #     else: self.ui.pushButton_save_changes.setEnabled(True), \
    #           self.ui.pushButton_cancel_changes.setEnabled(True)
    #
    #
    #
    #
    # # Сохранение изменений в листе категорий
    # def save_category_changes(self):
    #     error_message = QtWidgets.QMessageBox()
    #     error_message.setWindowTitle('Изменение категорий')
    #     error_message.setWindowIcon(QtGui.QIcon('icons/save_or_not.png'))
    #     error_message.setText("Вы хотите сохранить изменения?      ")
    #     error_message.setStandardButtons(QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No)
    #
    #     result = error_message.exec_()
    #
    #     mass = [self.ui.listWidget_categories.item(row).text().lower() for row in
    #             range(self.ui.listWidget_categories.count())]  # Получение элементов в listWidget
    #
    #
    #     if result == QtWidgets.QMessageBox.Yes:
    #
    #         folder = Path(self.ui.lineEdit_files_directory.text())
    #
    #         NewCategories = [category for category in mass if category not in self.previous_categories]
    #         NewCategories = NewCategories[::-1]
    #
    #         ### Сдвиг папок
    #
    #         # Добавление новых категорий
    #         for category in NewCategories:
    #             FolderName = str(folder) + "\\" + category + '{-'
    #
    #             try:
    #                 os.mkdir(FolderName)
    #
    #                 for file in folder.iterdir():
    #                     if file.name != 'output' and file.name != category + '{-':
    #
    #                         # print(str(file), f'{FolderName}\\{file.name}')
    #                         os.replace(str(file), f'{FolderName}\\{file.name}') # (исправить) Не работает при нулевом уровне "место{-"
    #                         # print(str(file), f'{FolderName}\\{file.name}')
    #
    #             except: raise OSError
    #
    #
    #         # Удаление старых категорий
    #         def CategoryDelete(folder):
    #             folder = Path(folder)
    #             self.level_k += 1
    #
    #             for file in folder.iterdir():
    #                 if file.name != 'output':
    #                     if self.level_k < level:
    #                         CategoryDelete(str(file))
    #
    #                     else:
    #                         for file_ in file.iterdir():
    #                             os.replace(str(file_), f'{str(folder)}\\{file_.name}')
    #
    #                         shutil.rmtree(str(file))
    #
    #
    #         for category in self.previous_categories:
    #             if category not in mass: # Нашли удаленную категорию
    #                 self.level_k = -1
    #                 level = self.previous_categories.index(category)
    #
    #                 CategoryDelete(str(folder))
    #
    #         ###
    #
    #         try:
    #             with open("config.txt", "r+", encoding='utf-8') as f:
    #                 config_txt = f.readlines()
    #                 categories = mass
    #
    #                 new_config = ""
    #
    #                 for i in range(len(categories)):
    #                     if i < len(categories) - 1:
    #                         new_config += categories[i] + ','
    #                     else: new_config += categories[i]
    #
    #                 new_config += "\n"
    #
    #                 for i in range(1, len(config_txt)): new_config += config_txt[i]
    #
    #                 f.seek(0)
    #                 f.truncate()
    #                 f.write(new_config)
    #
    #         except:
    #             error_message = QtWidgets.QMessageBox()
    #             error_message.setWindowTitle('Ошибка!')
    #             error_message.setWindowIcon(QtGui.QIcon('icons/error_window_icon.png'))
    #             error_message.setText("Корневые файлы программы повреждены,\n программа нуждается в перезагрузке.")
    #             error_message.setDefaultButton(QtWidgets.QMessageBox.Yes)
    #
    #             error_message.exec_()
    #             app.exit()
    #
    #         self.ui.categories_creator(True)
    #
    #         self.ui.categories_mass = mass
    #
    #         self.ui.pushButton_save_changes.setEnabled(False)
    #         self.ui.pushButton_cancel_changes.setEnabled(False)
    # #
    #
    # # Отмена изменений в листе категорий
    # def cancel_changes(self):
    #     self.ui.listWidget_categories.clear()
    #
    #     for i in range(len(self.ui.categories_mass)):
    #         item = QtWidgets.QListWidgetItem()
    #         item.setText(self.ui.categories_mass[i][0].upper() + self.ui.categories_mass[i][1:])
    #         self.ui.listWidget_categories.addItem(item)
    #
    #     if not(self.ui.pushButton_deletecategory.isEnabled()):
    #         self.ui.pushButton_deletecategory.setEnabled(True)
    #
    #     self.ui.pushButton_cancel_changes.setEnabled(False)
    #     self.ui.pushButton_save_changes.setEnabled(False)
    # #
    #
    #
    # def recursive_load(self, folder):
    #
    #     _files = [] # Двумерный массив с тегами каждого файла
    #     folder_mass = [] # Названия файлов в папке
    #     actual_tags = []
    #     folder = Path(folder)
    #     level_category = self.ui.categories_mass[self.levels]
    #
    #
    #     for file in folder.iterdir():
    #         a = file.name.split("{")
    #
    #         if a[0] != 'output' and file.is_dir():
    #             _files.append(a[-1].split(","))  # Массив разделенных тегов
    #             folder_mass.append(str(file))
    #
    #
    #     flag = False  # Флаг на вхождение категории уровня в заданные пользователем категории
    #
    #
    #     for i in range(self.ui.listWidget_categories.count()):
    #         if self.ui.listWidget_mass[i].count() > 0 \
    #                 and level_category == self.ui.label_categories_mass[i].text().lower()[:-1]: # Категория этого уровня задана пользователем
    #
    #                 flag = True
    #                 actual_tags = []  # Теги в заданной категории конкретного уровня
    #
    #                 for ind in range(self.ui.listWidget_mass[i].count()):
    #                     actual_tags.append(self.ui.listWidget_mass[i].item(ind).text().lower())
    #
    #                 break
    #
    #     if flag:
    #         test_result = self.load_name_test(_files, actual_tags, folder_mass)
    #
    #         if test_result == False: # Нет подходящей папки
    #
    #             _name_of_new_folder = str(folder) + '\\' + level_category + '{'
    #
    #             for i in range(len(actual_tags)):
    #                 _name_of_new_folder += actual_tags[i]
    #
    #                 if i != len(actual_tags) - 1:
    #                     _name_of_new_folder += ","
    #
    #             os.mkdir(_name_of_new_folder)
    #
    #             if self.levels != len(self.ui.categories_mass) - 1: # Если мы не дошли до последнего уровня
    #                 self.levels += 1
    #                 self.recursive_load(_name_of_new_folder)
    #
    #             else:
    #                 self.files_loading(_name_of_new_folder)
    #
    #         else: # Нашлась подходящая папка
    #
    #             if self.levels != len(self.ui.categories_mass) - 1:
    #                 self.levels += 1
    #                 self.recursive_load(test_result)
    #
    #             else: # Дошли до конечной папки
    #                 self.files_loading(test_result)
    #
    #
    #     else: # Категория на данном уровне не задана
    #         _ = str(folder) + '\\' + level_category + '{-'
    #
    #         _flag = False
    #
    #         for i in _files:
    #             if '-' in i:
    #                 _flag = True
    #
    #         if not(_flag): os.mkdir(_)
    #
    #         if self.levels != len(self.ui.categories_mass) - 1:
    #             self.levels += 1
    #             self.recursive_load(_)
    #
    #         else:
    #             self.files_loading(_)
    #
    #
    # def files_loading(self, name_of_new_folder):
    #
    #     for i in range(len(self.files)):
    #         _newname = name_of_new_folder + '\\' + self.files[i].split('/')[-1]
    #
    #         if self.ui.checkBox_setting3.checkState():
    #             os.rename(self.files[i], _newname)
    #         else:
    #             shutil.copyfile(self.files[i], _newname)
    #
    #
    #
    #
    # def load_name_test(self, _files, actual_tags, folder_mass): # Проверка на вхождение папки с необходимыми тегами
    #
    #     for mass_ in _files:
    #         _local_flag = True
    #
    #         for tag in actual_tags:
    #
    #             if len(actual_tags) != len(mass_) or tag not in mass_:
    #                 _local_flag = False
    #                 break
    #
    #         if _local_flag:
    #             return (folder_mass[_files.index(mass_)])
    #
    #
    #     return False
    #
    #
    #
    #
    # def load_files(self):
    #     self.files = QtWidgets.QFileDialog.getOpenFileNames(self,
    #                                                    'Выберите несколько файлов',
    #                                                    ".",
    #                                                    "Allfiles(*.*)")[0]
    #
    #     _check_mass = []
    #
    #     self.levels = 0
    #     self.recursive_load(self.ui.lineEdit_files_directory.text())
    #
    #
    #     for a in range(8):
    #         self.ui.listWidget_mass[a].clear()
    #         self.ui.pushButton_category_delete_mass[a].setEnabled(False)
    #         self.ui.pushButton_categories_color_mass[a].setEnabled(False)
    #         self.ui.pushButton_category_change_priority_mass[a].setEnabled(False)
    #         self.ui.lineEdit_tags_mass[a].clear()
    #
    #     for i in range(len(self.ui.history_category_tags)):
    #         self.ui.history_category_tags[i].sort()
    #
    #     # self.history_recreator()   # Исправить!!!!!!!!
    #
    #     self.PushButtons_return_StyleSheet()
    #
    #     self.ui.pushButton_load.setEnabled(False)
    #     self.ui.pushButton_open.setEnabled(False)
    #     self.ui.pushButton_delete_files.setEnabled(False)
    #     self.ui.pushButton_clean_all_files.setEnabled(True)
    #
    #     self.category_colors_mass = bytearray((0, 0, 0, 0, 0, 0, 0, 0))
    #     self.tags_priority = [[], [], [], [], [], [], [], []]
    #
    #
    # def open_files(self):
    #
    #     ### Очистка файлов в папке output
    #     filelist = [f for f in os.listdir(self.ui.output_trail)]
    #     for file in filelist: os.remove(os.path.join(self.ui.output_trail, file))
    #     ###
    #
    #     self.active_categories_ind = []
    #     self.active_categories_names = []
    #
    #     ### Определяем активные категории
    #     for i in range(self.ui.listWidget_categories.count()):
    #         if self.ui.listWidget_mass[i].count() != 0:
    #             _category = self.ui.label_categories_mass[i].text().lower()[:-1]
    #             self.active_categories_ind.append(i)
    #             self.active_categories_names.append(_category)
    #     ###
    #
    #
    #     self.files_count = 0
    #     self.file_found_flag = False # Флаг на нахождение медиафайла
    #
    #     folder = self.ui.lineEdit_files_directory.text()
    #     self.recursive_search(folder)
    #
    #
    #     if self.file_found_flag:
    #         os.system(f"explorer.exe {self.ui.output_trail}")
    #     else:
    #         os_message = QtWidgets.QMessageBox()
    #         os_message.setWindowTitle(" ")
    #         os_message.setText("По заданным категориям не было найдено ни одного файла.        ")
    #         os_message.setWindowIcon(QtGui.QIcon('icons/folder.png'))
    #         os_message.setStandardButtons(QtWidgets.QMessageBox.Ok)
    #
    #         os_message.exec_()
    #
    #     # Возвращение главной страницы к исходному виду
    #     self.reload()
    #
    #
    #
    # def recursive_search(self, folder):
    #     folder = Path(folder)
    #
    #     for file in folder.iterdir():  # Перебор всех файлов в folder
    #
    #         if file.is_dir():
    #             file_name = file.name.split("'\'")[-1].split("§")
    #             file_name = file_name[0].split('{')
    #             main_flag = True
    #             blue_test = True
    #             red_tag_in = False
    #             green_test = False
    #
    #             if file_name[0] == 'output': continue
    #
    #             _index = -1
    #             folder_category = file_name[0]
    #             _list_widget_elements_mass = []  # Теги в лв по категории папки
    #             folder_category_tags = file_name[1].split(',')  # Массив с разделенными тегами в названии папки
    #
    #
    #             if folder_category in self.active_categories_names:
    #
    #                 _index = self.active_categories_ind[self.active_categories_names.index(folder_category)]
    #
    #                 _red_tags = []
    #                 _blue_tags = []
    #                 _green_tags = []
    #
    #                 for row in range(self.ui.listWidget_mass[_index].count()):
    #                     _list_widget_elements_mass.append(self.ui.listWidget_mass[_index].item(row).text().lower())
    #
    #                     if self.tags_priority[_index][row] == 0:
    #                         _green_tags.append(self.ui.listWidget_mass[_index].item(row).text().lower())
    #                     elif self.tags_priority[_index][row] == 1:
    #                         _blue_tags.append(self.ui.listWidget_mass[_index].item(row).text().lower())
    #                     else:
    #                         _red_tags.append(self.ui.listWidget_mass[_index].item(row).text().lower())
    #
    #
    #                 for tag in _red_tags:
    #                     if tag in folder_category_tags:
    #                         red_tag_in = True
    #                         break
    #
    #
    #                 if len(_green_tags) != 0:
    #                     blue_test = False
    #
    #                     for tag in _green_tags:
    #                         if tag in folder_category_tags:
    #                             green_test = True
    #                             break
    #
    #
    #                 elif len(_blue_tags) != 0:
    #                     green_test = False
    #
    #                     for tag in _blue_tags:
    #                         if tag not in folder_category_tags:
    #                             blue_test = False
    #                             break
    #
    #
    #                 if not (not (red_tag_in) and (green_test or blue_test)):
    #                     main_flag = False
    #
    #
    #             if main_flag: # Папка подошла
    #                 self.recursive_search(file)
    #
    #
    #         else: # Дошли до листьев
    #             self.files_count += 1
    #             self.file_found_flag = True
    #             newname = self.ui.output_trail + "\\" + str(self.files_count) + '.' + file.name.split('.')[-1]
    #             shutil.copyfile(file, newname)
    #
    #
    # def PushButton_delete_files(self):
    #     error_message = QtWidgets.QMessageBox()
    #     error_message.setWindowTitle('Удаление файлов')
    #     error_message.setWindowIcon(QtGui.QIcon('icons/save_or_not.png'))
    #     error_message.setText("Вы точно хотите безвозвратно удалить медиафайлы по заданным тегам?      ")
    #     error_message.setStandardButtons(QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No)
    #
    #     result = error_message.exec_()
    #
    #     if result == QtWidgets.QMessageBox.Yes:
    #
    #         folder = Path(self.ui.lineEdit_files_directory.text())
    #
    #         for file in folder.iterdir():
    #             file_name = file.name.split("'\'")[-1].split("§")
    #
    #             _flag = True  # Флаг на прохождение файла по категориям
    #             _found = False  # Флаг на нахождение хотя бы 1 категории в файле
    #
    #             # Отделяем теги от категории
    #             for i in range(len(file_name) - 1):
    #                 file_name[i] = file_name[i].split("{")
    #
    #             for i in range(self.ui.listWidget_categories.count()):
    #                 if self.ui.listWidget_mass[i].count() != 0:
    #
    #                     _list_widget_elements_mass = (self.ui.listWidget_mass[i].item(row).text().lower() for
    #                                                   row in range(self.ui.listWidget_mass[i].count()))
    #
    #                     for j in range(len(file_name) - 1):
    #                         # формат file_name[j] - (теги...), file_name[0] - категория
    #
    #                         # Нахождение нужной категории в file_name[j]
    #                         if self.ui.label_categories_mass[i].text().lower()[:-1] in file_name[j]:
    #                             _found = True
    #
    #                             _file_tags = file_name[j][-1].split(',')  # Массив с тегами
    #
    #                             # Перебор всех тегов в file_name по найденной категории
    #                             for f in range(len(_file_tags)):
    #
    #                                 if (_file_tags[f] not in _list_widget_elements_mass):
    #                                     _flag = False
    #                                     break
    #
    #                             break
    #                 if not (_flag): break
    #
    #             if _flag and _found:
    #                 os.remove(os.path.join(self.ui.sklad_trail, file.name))
    #
    #         # Возвращение главной страницы к исходному виду
    #         self.reload()
    #
    #
    # def save_settings(self):
    #
    #     try:
    #         with open("config.txt", "r+", encoding='utf-8') as f:
    #             config_txt = f.readlines()
    #             new_config = config_txt[0]
    #
    #             new_config += str(int(self.ui.checkBox_setting1.isChecked())) + ',' \
    #                           + str(int(self.ui.checkBox_setting2.isChecked())) + ',' \
    #                           + str(int(self.ui.checkBox_setting3.isChecked()))
    #
    #             new_config += "\n"
    #
    #             self.ui.settings_mass[0] = self.ui.checkBox_setting1.isChecked()
    #             self.ui.settings_mass[1] = self.ui.checkBox_setting2.isChecked()
    #             self.ui.settings_mass[2] = self.ui.checkBox_setting3.isChecked()
    #
    #             for i in range(2, len(config_txt)): new_config += config_txt[i]
    #
    #             f.seek(0)
    #             f.truncate()
    #             f.write(new_config)
    #
    #             self.ui.pushButton_save_settings.setEnabled(False)
    #             self.ui.pushButton_delete_settings.setEnabled(False)
    #
    #     except:
    #         error_message = QtWidgets.QMessageBox()
    #         error_message.setWindowTitle('Ошибка!')
    #         error_message.setWindowIcon(QtGui.QIcon('icons/error_window_icon.png'))
    #         error_message.setText("Корневые файлы программы повреждены,\n программа нуждается в перезагрузке.")
    #         error_message.setDefaultButton(QtWidgets.QMessageBox.Yes)
    #
    #         error_message.exec_()
    #         app.exit()
    #
    #
    #
    # def delete_all_files(self):
    #     error_message = QtWidgets.QMessageBox()
    #     error_message.setWindowTitle('Очистка корневой папки')
    #     error_message.setWindowIcon(QtGui.QIcon('icons/save_or_not.png'))
    #     error_message.setText("Вы точно хотите безвозвратно удалить все медиафайлы?      ")
    #     error_message.setStandardButtons(QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No)
    #
    #     result = error_message.exec_()
    #
    #     if result == QtWidgets.QMessageBox.Yes:
    #         filelist = [f for f in os.listdir(self.ui.sklad_trail)]
    #         for file in filelist:
    #             if file != 'output':
    #                 os.remove(os.path.join(self.ui.sklad_trail, file))
    #
    #         self.ui.pushButton_clean_all_files.setEnabled(False)
    #
    #
    #
    def keyPressEvent(self, e):
        if self.ui.tabWidget.currentIndex() == 0: # Главный таб

            if e.key() == Qt.Key_Return:
                self.add_tag(-1)

            # elif (e.key() == QtCore.Qt.Key_L or e.key() == 1044) and self.ui.pushButton_load.isEnabled():
            #     self.load_files()
            #
            # elif (e.key() == QtCore.Qt.Key_O or e.key() == 1065) and self.ui.pushButton_open.isEnabled():
            #     self.open_files()
            #
            # elif (e.key() == QtCore.Qt.Key_D or e.key() == 1042) and self.ui.pushButton_delete_files.isEnabled():
            #     self.PushButton_delete_files()


        # elif self.ui.tabWidget.currentIndex() == 2: # Таб с категориями
        #     if e.key() == QtCore.Qt.Key_Return:
        #         self.add_category()


    #
    # def eventFilter(self, obj, event):
    #     if obj == self.ui.pushButton_deletecategory:
    #         if event.type() == QtCore.QEvent.HoverEnter:
    #             self.ui.pushButton_deletecategory.setIcon(QtGui.QIcon("icons/trashOn.png"))
    #         elif event.type() == QtCore.QEvent.HoverLeave:
    #             self.ui.pushButton_deletecategory.setIcon(QtGui.QIcon("icons/trash.png"))
    #
    #     return super(MM_body, self).eventFilter(obj, event)
    #
    #
    # def change_all_item_priority(self, called_by):
    #     # print(self.category_colors_mass[called_by])
    #     if self.category_colors_mass[called_by] == 0:
    #         self.ui.pushButton_categories_color_mass[called_by].setStyleSheet("QPushButton {"
    #                                                                           "background-color: #0D2DFF; border-radius: 7px; border: 1px solid #8a8a8a}"
    #                                                                           "QPushButton::hover {background-color: #2542FF;}")
    #         self.ui.pushButton_category_change_priority_mass[called_by].setIcon(QtGui.QIcon("icons/br.png"))
    #
    #     else:
    #         self.ui.pushButton_categories_color_mass[called_by].setStyleSheet("QPushButton {"
    #                                                                           "background-color: #3CFF00; border-radius: 7px; border: 1px solid #8a8a8a}"
    #                                                                           "QPushButton::hover {background-color: #83FF5C;}")
    #         self.ui.pushButton_category_change_priority_mass[called_by].setIcon(QtGui.QIcon("icons/gr.png"))
    #     # print('da')
    #     if self.category_colors_mass[called_by] < len(self.colors) - 2:
    #         self.category_colors_mass[called_by] += 1
    #     else:
    #         self.category_colors_mass[called_by] = 0
    #     # print(self.category_colors_mass[called_by])
    #     for row in range(self.ui.listWidget_mass[called_by].count()):
    #         # print(f'row = {row}\n{self.tags_priority}')
    #         if self.tags_priority[called_by][row] != len(self.colors) - 1: # Проверка на то, что тег не красный
    #             # print(self.tags_priority)
    #             # print(self.tags_priority[called_by][row])
    #             self.ui.listWidget_mass[called_by].item(row).setForeground(
    #                 QtGui.QColor(self.colors[self.category_colors_mass[called_by]]))
    #             # print(self.tags_priority[called_by][row] )
    #             self.tags_priority[called_by][row] = self.category_colors_mass[called_by]
    #
    #
    #
    # def change_item_priority(self, called_by, _flag = False):
    #     a = self.ui.listWidget_mass[called_by].selectedIndexes()
    #
    #     # Убираем выделение эл-та
    #     _items_mass = []
    #
    #     for i in a: _selected_index = i.row()
    #
    #     for i in range(self.ui.listWidget_mass[called_by].count()):
    #         item = self.ui.listWidget_mass[called_by].item(i)
    #         name = item.text()
    #         foreground = item.foreground()
    #         _items_mass.append([name, foreground])
    #
    #     self.ui.listWidget_mass[called_by].clear()
    #
    #     for i in range(len(_items_mass)):
    #         newItem = QtWidgets.QListWidgetItem()
    #         newItem.setText(_items_mass[i][0])
    #         newItem.setForeground(_items_mass[i][1])
    #         self.ui.listWidget_mass[called_by].addItem(newItem)
    #     #
    #
    #
    #     for i in a:
    #         # Изменение индекса цвета для выбранного эл-та
    #
    #         if self.tags_priority[called_by][i.row()] == self.category_colors_mass[called_by]:
    #             self.tags_priority[called_by][i.row()] = len(self.colors) - 1
    #         else: self.tags_priority[called_by][i.row()] = self.category_colors_mass[called_by]
    #
    #         # Изменение цвета эл-та
    #         self.ui.listWidget_mass[called_by].item(i.row()).setForeground(QtGui.QColor(self.colors[self.tags_priority[called_by][i.row()]]))
    #         _flag = True
    #
    #     if _flag == False:
    #         # Изменение индекса цвета для последнего эл-та
    #         if self.tags_priority[called_by][-1] == self.category_colors_mass[called_by]:
    #             self.tags_priority[called_by][-1] = len(self.colors) - 1
    #         else: self.tags_priority[called_by][-1] = self.category_colors_mass[called_by]
    #
    #         self.ui.listWidget_mass[called_by].item(self.ui.listWidget_mass[called_by].count() - 1).setForeground(QtGui.QColor(self.colors[self.tags_priority[called_by][-1]]))
    #
    #
    #
    #
    # def check_box_func(self):
    #     if (self.ui.checkBox_setting1.isChecked() == self.ui.settings_mass[0]) \
    #             and (self.ui.checkBox_setting2.isChecked() == self.ui.settings_mass[1]) \
    #             and (self.ui.checkBox_setting3.isChecked() == self.ui.settings_mass[2]):
    #         self.ui.pushButton_save_settings.setEnabled(False)
    #         self.ui.pushButton_delete_settings.setEnabled(False)
    #
    #     else:
    #         self.ui.pushButton_save_settings.setEnabled(True)
    #         self.ui.pushButton_delete_settings.setEnabled(True)
    #
    #
    #
    # def PushButtons_return_StyleSheet(self):
    #     for i in range(self.ui.listWidget_categories.count()):
    #         self.ui.pushButton_categories_color_mass[i].setStyleSheet("QPushButton {"
    #                                                                "background-color: #c7c7c7; border-radius: 7px; border: 1px solid #8a8a8a}"
    #                                                                "QPushButton::hover {background-color: #dedede;}"
    #                                                                "QPushButton::pressed {background-color: #dadada;}")
    #
    #
    # def listWidget_history_tags_creator(self):
    #
    #     self.ui.listWidget_history_tags.clear()
    #     index = self.ui.listWidget_history_all_categories.currentRow()
    #
    #
    #     if index <= len(self.ui.white_history_tags) - 1:
    #         self.ui.listWidget_history_tags.setEnabled(True)
    #
    #         for j in range(len(self.ui.white_history_tags[index])):
    #             item = QtWidgets.QListWidgetItem()
    #             item.setText(self.ui.white_history_tags[index][j][0].upper() + self.ui.white_history_tags[index][j][1:])
    #             item.setTextAlignment(QtCore.Qt.AlignHCenter)
    #
    #             self.ui.listWidget_history_tags.addItem(item)
    #
    #     else:
    #         index -= len(self.ui.white_history_tags)
    #         for i in range(len(self.ui.grey_history_tags[index])):
    #             item = QtWidgets.QListWidgetItem()
    #             item.setText(self.ui.grey_history_tags[index][i][0].upper() + self.ui.grey_history_tags[index][i][1:])
    #             item.setTextAlignment(QtCore.Qt.AlignHCenter)
    #
    #             self.ui.listWidget_history_tags.addItem(item)
    #         self.ui.listWidget_history_tags.setEnabled(False)
    #
    #     self.window_resize("change")
    #
    #
    # def history_recreator(self):
    #     self.ui.listWidget_history_tags.clear()
    #     self.ui.listWidget_history_all_categories.clear()
    #
    #     for i in range(len(self.ui.history_files_categories)):
    #         item = QtWidgets.QListWidgetItem()
    #         item.setText(self.ui.history_files_categories[i][0].upper() + self.ui.history_files_categories[i][1:])
    #         item.setTextAlignment(QtCore.Qt.AlignHCenter)
    #
    #         self.ui.listWidget_history_all_categories.addItem(item)
    #
    #     for j in range(len(self.ui.history_category_tags[0])):
    #         item = QtWidgets.QListWidgetItem()
    #         item.setText(self.ui.history_category_tags[0][j][0].upper() + self.ui.history_category_tags[0][j][1:])
    #         item.setTextAlignment(QtCore.Qt.AlignHCenter)
    #
    #         self.ui.listWidget_history_tags.addItem(item)
    #
    #     self.ui.listWidget_history_all_categories.item(0).setSelected(True)
    #
    #
    #
    # def add_tags_from_history(self):
    #     a = self.ui.listWidget_history_tags.selectedIndexes()
    #     b = self.ui.listWidget_history_all_categories.selectedIndexes()
    #     for i in a: _pressed_itemIndex = i.row()
    #     for i in b: _selected_categoryIndex = i.row()
    #
    #     for i in range(len(self.ui.label_categories_mass)):
    #         # Нахождение нужной категории на главной странице
    #         if self.ui.label_categories_mass[i].text().lower()[:-1] == self.ui.listWidget_history_all_categories.item(_selected_categoryIndex).text().lower():
    #
    #             self.ui.lineEdit_tags_mass[i].setText(self.ui.listWidget_history_tags.item(_pressed_itemIndex).text())
    #             self.add_tags(i)
    #             break
    #
    #
    #
    # # Возвращение главной страницы к исходному виду
    # def reload(self):
    #     self.category_colors_mass = bytearray((0, 0, 0, 0, 0, 0, 0, 0))
    #     self.tags_priority = [[], [], [], [], [], [], [], []]
    #
    #     for i in range(self.ui.listWidget_categories.count()):
    #         self.ui.listWidget_mass[i].clear()
    #         self.ui.pushButton_open.setEnabled(False)
    #         self.ui.pushButton_load.setEnabled(False)
    #         self.ui.pushButton_delete_files.setEnabled(False)
    #         self.ui.pushButton_category_delete_mass[i].setEnabled(False)
    #         self.ui.pushButton_categories_color_mass[i].setEnabled(False)
    #         self.ui.pushButton_category_change_priority_mass[i].setEnabled(False)
    #
    #     self.PushButtons_return_StyleSheet()
    #
    #
    def window_resize(self, type):
        tabIndex = self.ui.tabWidget.currentIndex()
    
        self.animation = QPropertyAnimation(self, b'size')
        self.animation.setDuration(500)
        self.animation.setEasingCurve(QEasingCurve.Linear)
    
        if type == 'start': # Первый запуск программы
            self.animation.setDuration(500)
            self.animation.setEasingCurve(QEasingCurve.Linear)
            self.animation.setStartValue(QSize(20,20))
            self.animation.setEndValue(QSize(500, 540)) #self.ui.main_width, _heigh
            self.animation.start()
    
        elif type == "change": # Переключение между вкладками программы 
            # Проверка на несохраненные значения в окне настроек  
            if self.LastIndex == 1 and self.ui.pushButton_save_settings.isEnabled():
                error_message = QMessageBox()
                error_message.setWindowTitle('Изменение настроек')
                error_message.setWindowIcon(QIcon('icons/save_or_not.png'))
                error_message.setText("Вы хотите сохранить изменения?      ")
                error_message.setStandardButtons(QMessageBox.Yes | QMessageBox.No)
    
                result = error_message.exec_()
    
                if result == QMessageBox.Yes:
                    self.save_settings()
                else:
                    self.ui.settings_init()
        
        elif type == 'left_window_opening':
            print(application.size())
            self.animation.setStartValue(application.size())
            self.animation.setEndValue(QSize(580, 620))
            self.animation.start()

        elif type == 'right_window_opening':
            self.animation.setStartValue(application.size())
            self.animation.setEndValue(QSize(1250, 620))
            self.animation.start()

        self.LastIndex = tabIndex

    def pushbutton_style_creator(self, pushbutton):
        pushbutton.setStyleSheet("QPushButton {background-color: #c7c7c7; border-radius: 7px; border: 1px solid #8a8a8a}"
                                                "QPushButton::hover {background-color: #dedede;}"
                                                "QPushButton::pressed {background-color: #dadada;}")
        self.setShadowEffect(pushbutton)


    def setShadowEffect(self, object):
        shadow = QGraphicsDropShadowEffect()
        shadow.setBlurRadius(4)
        shadow.setXOffset(0)
        shadow.setYOffset(0)

        object.setGraphicsEffect(shadow)

        # shadow = QGraphicsDropShadowEffect()
        # shadow.setBlurRadius(2)
        # shadow.setXOffset(1)
        # shadow.setYOffset(1)
        #
        # object.setGraphicsEffect(shadow)






# Установка иконки приложения
try:
    from PyQt5.QtWinExtras import QtWin
    myappid = 'mycompany.myproduct.subproduct.version'
    QtWin.setCurrentProcessExplicitAppUserModelID(myappid)
except ImportError:
    print('MacOS opening')


if __name__ == '__main__':
    app = QApplication([])
    app.setStyle(QStyleFactory.keys()[-1])
    application = MM_body()
    application.show()
    application.setWindowIcon(QIcon("icons/WindowIcon.png"))

    sys.exit(app.exec_())

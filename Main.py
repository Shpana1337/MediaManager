# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'newdesign.ui'
#
# Created by: PyQt5 UI code generator 5.15.7
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

import sys
import array
import shutil
import sqlite3
from time import time
from sys import platform
from pathlib import Path
from os import remove, stat
from collections import Counter
from statistics import mean

import PyQt5.QtMultimediaWidgets
from screeninfo import get_monitors
from PyQt5.QtGui import QPixmap, QIcon, QPainter, QPaintEvent, QColor
from moviepy.editor import VideoFileClip
from PyQt5.QtMultimediaWidgets import QGraphicsVideoItem
from PyQt5.QtMultimedia import QMediaPlayer, QMediaContent
from PyQt5.QtCore import QUrl, QSize, Qt, QPropertyAnimation, QEasingCurve, QPoint, QRect, \
                        QTimer, pyqtSlot, pyqtSignal, QParallelAnimationGroup, QAbstractAnimation
from PyQt5.QtWidgets import QHBoxLayout, QVBoxLayout, QListWidget, QPushButton, QLabel, \
    QMainWindow, QFileDialog, QLineEdit, QApplication, QStyleFactory, QWidget, \
    QListWidgetItem, QGraphicsDropShadowEffect, QSpacerItem, QSizePolicy, QComboBox, QMessageBox, QGraphicsOpacityEffect

from ui import Ui_MainWindow
from AnimatedEffects import AnimatedShadowEffect

class MMBody(QMainWindow):
    def __init__(self):
        super(MMBody, self).__init__()
        self.ui = Ui_MainWindow()
        self.ui.setupUi(self)
        self.setWindowTitle('МедиаМенеджер')

        #self.levels = 0
        #self.LastIndex = 0
        self.animation = None
        self.LastIndex = None
        self.left_arrow = None
        self.right_arrow = None
        self.save_button = None
        self.cancel_button = None
        self.move_animation = None
        self.opacity_animation = None
        self.right_window_label = None
        self.pressed_button_index = None
        self.button_cancel_selection = None
        self.selection_type = 1
        self.first_pressed_index = -1
        self.second_pressed_index = -1
        self.previous_button_index = 0
        self.line_edits_mass = []
        self.list_widget_mass = []
        self.add_buttons_mass = []
        self.photo_button_mass = []
        self.delete_buttons_mass = []
        self.selected_files_mass = []
        self.button_is_photo_mass = []
        self.previous_tags_mass = []
        self.selected_files_way_mass = []
        self.paths_to_all_files_list = []
        self.shadow_effect = AnimatedShadowEffect()
        self.changed_tags_indexes_list = set()
        self.first_frame_folder = Path('icons_cache')
        self.right_window_is_open = False

        self.button_stylesheet_settings = "QPushButton {background-color: #c7c7c7; " \
                                          "border-radius: 7px; border: 1px solid #8a8a8a} " \
                                          "QPushButton::hover {background-color: #dedede; " \
                                          "QPushButton::pressed {background-color: #dadada;} " \
                                          "QToolTip {border: 1px solid black; background-color: white}"
        self.pushbutton_style_creator(pushbutton=self.ui.pushbutton_open_folder)
        self.db_init()
        self.window_resize(type_="start")

        self.ui.pushbutton_open_folder.pressed.connect(self.open_folder)
        # Конфигурация чекбоксов
        # self.ui.checkBox_setting1.stateChanged.connect(self.check_box_func)
        # self.ui.checkBox_setting2.stateChanged.connect(self.check_box_func)
        # self.ui.checkBox_setting3.stateChanged.connect(self.check_box_func)
        # #

        # self.ToolTip_enable()
        # self.ui.tabWidget.currentChanged.connect(lambda: self.window_resize('change'))
        # self.ui.listWidget_history_all_categories.currentRowChanged.connect(self.listWidget_history_tags_creator)
        # self.ui.listWidget_history_tags.itemDoubleClicked.connect(self.add_tags_from_history)
        #
        # Конфигурация кнопок


        # self.ui.nextPageButton.pressed.connect(self.next_page)
        # self.ui.previousPageButton.pressed.connect(self.previous_page)
        # self.ui.pushButton_save_settings.pressed.connect(self.save_settings)
        # self.ui.pushButton_delete_settings.pressed.connect(self.ui.settings_init)
        # self.ui.pushButton_clean_all_files.pressed.connect(self.delete_all_files)
        #
        # self.ui.pushButton_open.pressed.connect(self.open_files)
        # self.ui.pushButton_load.pressed.connect(self.load_files)
        # self.ui.pushButton_delete_files.pressed.connect(self.PushButton_delete_files)


    def open_folder(self) -> None:
        for file in self.first_frame_folder.iterdir():
            remove(file)

        dirlist = QFileDialog.getExistingDirectory(self, "Выбрать папку", ".")
        path = Path(dirlist)

        self.layout_cleaner(layout=self.ui.verticalLayout_11)

        files_was_founded = False
        self.paths_to_all_files_list = []
        self.changed_tags_indexes_list = set()
        video_formats = ('mov', 'avi', 'mp4')
        photo_formats = ('jpg', 'jpeg', 'png')

        for file in path.iterdir():
            _file_name = file.name
            _file_way = f"{dirlist}/{_file_name}"

            if _file_name.lower().endswith(photo_formats):
                files_was_founded = True
                self.block_creator(file_way=_file_way, file_is_photo=True)
                self.paths_to_all_files_list.append(_file_way)

            elif _file_name.lower().endswith(video_formats):
                files_was_founded = True
                self.block_creator(file_way=_file_way, file_is_photo=False)
                self.paths_to_all_files_list.append(_file_way)

        if files_was_founded:
            self.upper_lower_layouts_creating()

        self.opening_adding_tags()
        self.previous_tags_mass = self.all_tags_mass_creating()
        self.window_resize(type_="left_window_opening")

        # present_tags = self.all_tags_mass_creating()
        # tag_founded_flag = False
        #
        # for el in present_tags:
        #     print(el)
        #     if el:
        #         tag_founded_flag = True
        #         break
        #
        # if tag_founded_flag:
        #     self.save_button.setEnabled(True)
        #     self.cancel_button.setEnabled(True)


    def block_creator(self, file_way: str, file_is_photo: bool) -> None:
        """
        Функция создает блоки с медиафайлами, тегами и кнопками.

        :param ui.verticalLayout_11: Лэйаут scroll виджета.
        :param horizontal_layout: Главный layout блока.
        :param vertical_layout: Правый лэйаут блока с list widget и layout с кнопками.
        :param file_way: Путь к медиафайлу.
        :param file_is_photo: Булева переменная, показывает является ли файл фотографией.
        """
        # Сборка главного лэйаута блока
        horizontal_layout = QHBoxLayout()
        button_photo = QPushButton()
        button_photo.setMinimumSize(QSize(250, 170))

        if file_is_photo:
            icon = file_way
            self.button_is_photo_mass.append(True)
        # file is video
        else:
            # Сохраняем первый кадр видео для иконки в кнопку
            video = VideoFileClip(file_way)
            video.save_frame(f'{self.first_frame_folder}/{len(self.photo_button_mass)}.png', t=1)

            icon = f'{self.first_frame_folder}/{len(self.photo_button_mass)}.png'
            self.button_is_photo_mass.append(False)

            # video_item = QGraphicsVideoItem()
            # video_item.setSize((QtCore.QSizeF(250,170)))
            #
            # scene = QtWidgets.QGraphicsScene(self)
            # scene.addItem(video_item)
            # graphicsView = QtWidgets.QGraphicsView(scene)
            # graphicsView.setMinimumSize(QtCore.QSize(250,170))
            # layout = QtWidgets.QVBoxLayout()
            # layout.addWidget(graphicsView)
            # self.setLayout(layout)
            # self.media_player = QMediaPlayer(None, QMediaPlayer.VideoSurface)
            # self.media_player.setVideoOutput(video_item)
            # self.media_player.setMedia(QMediaContent(QUrl.fromLocalFile(file_way)))
            #
            # self.media_player.play()
            # self.media_player.stop()
            #
            # horizontal_layout.addLayout(layout)

        button_photo.setIcon(QIcon(icon))
        button_photo.setIconSize(QSize(220, 160))
        button_photo.setStyleSheet("QPushButton {background-color: white;border-radius: 7px; border: 1px solid #8a8a8a}"
                                   "QPushButton::hover {background-color: #eaeaea;}"
                                   "QPushButton::pressed {background-color: #dadada;}")
        self.set_shadow_effect(object_=button_photo)

        horizontal_layout.addWidget(button_photo)
        self.photo_button_mass.append(button_photo)

        pressed_button_index = self.photo_button_mass.index(button_photo)
        button_photo.pressed.connect(lambda: self.right_window_changing(pressed_button_index=pressed_button_index))

        ## Сборка правого лэйаута
        vertical_layout = QVBoxLayout()

        list_widget = QListWidget()
        self.set_shadow_effect(object_=list_widget)

        button_delete_tag = QPushButton()
        button_delete_tag.setText('-')
        self.pushbutton_style_creator(pushbutton=button_delete_tag)
        button_delete_tag.setMinimumSize(50, 25)

        ### Сборка лэйаута для line edit и кнопки
        horizontal_layout_for_line_edit = QHBoxLayout()

        button_add_tag = QPushButton()
        button_add_tag.setText('+')

        self.pushbutton_style_creator(pushbutton=button_add_tag)
        button_add_tag.setMinimumSize(65, 25)

        line_edit = QLineEdit()
        line_edit.setPlaceholderText('Введите тег:')
        line_edit.setStyleSheet("QLineEdit {border-radius: 7px; border: 1px solid #8a8a8a;}")
        line_edit.setMinimumSize(70, 25)
        self.set_shadow_effect(object_=line_edit)

        horizontal_layout_for_line_edit.addWidget(line_edit)
        horizontal_layout_for_line_edit.addWidget(button_add_tag)
        ###

        vertical_layout.addWidget(list_widget)
        vertical_layout.addWidget(button_delete_tag)
        vertical_layout.addLayout(horizontal_layout_for_line_edit)
        ##

        horizontal_layout.addLayout(vertical_layout)
        #

        self.ui.verticalLayout_11.addLayout(horizontal_layout)

        self.line_edits_mass.append(line_edit)
        self.list_widget_mass.append(list_widget)
        self.add_buttons_mass.append(button_add_tag)
        self.delete_buttons_mass.append(button_delete_tag)

        pressed_button_index = self.add_buttons_mass.index(button_add_tag)

        button_add_tag.pressed.connect(lambda: self.add_tag(index_=pressed_button_index))
        button_delete_tag.pressed.connect(lambda: self.delete_tag(index_=pressed_button_index))


    def opening_adding_tags(self) -> None:
        """
        Функция добавляет ко всем файлам теги, если они были ранее загружены в базу данных.
        Вызывается только после открытия папки с медиафайлами.
        """
        if platform.startswith("win"):
            db_name = "winDataBase.db"
        else:
            db_name = "linDataBase.db"

        with sqlite3.connect(db_name) as db:
            cursor = db.cursor()
            _file_index = 0

            for _file_way in self.paths_to_all_files_list:
                _file_id = stat(_file_way, follow_symlinks=False).st_ino
                _device_id = stat(_file_way, follow_symlinks=False).st_dev
                # Linux/Mac OS
                if db_name.startswith("lin"):
                    _file_tags = cursor.execute("SELECT tags FROM media_files WHERE device_id = ? AND file_id = ?",
                                                (_device_id, _file_id)).fetchone()
                # Windows
                else:
                    # Добавить проверку по имени диска
                    _file_tags = cursor.execute("SELECT tags FROM media_files WHERE file_id = ?",
                                                (_file_id, )).fetchone()

                if _file_tags:
                    _file_tags = _file_tags[0].split(",")
                    self.list_widget_mass[_file_index].addItems(_file_tags)

                _file_index += 1


    def selection_type_change(self, value: int) -> None:
        """
        Функция меняет вид выделения файлов.

        :param value: Индекс выбранного метода выделения.
        """
        self.selection_type = value + 1
        self.right_block_cleaner()


    def upper_lower_layouts_creating(self) -> None:
        """
        Функция создает главное окно, в котором отображаются медиафайлы при открытии папки.
        """
        # Верхний лэйаут
        combo_box = QComboBox()
        combo_box.setMinimumSize(65, 25)
        combo_box.addItem('Одиночное выделение')
        combo_box.addItem('Выделение "от и до"')
        combo_box.addItem('Выборочное выделение')
        combo_box.currentIndexChanged.connect(self.selection_type_change)

        button_cancel_selection = QPushButton()
        button_cancel_selection.setText('Отменить выделение')
        button_cancel_selection.setMinimumSize(65, 25)
        button_cancel_selection.setMaximumSize(600, 25)
        button_cancel_selection.setEnabled(False)
        button_cancel_selection.pressed.connect(self.right_block_cleaner)
        self.button_cancel_selection = button_cancel_selection
        self.pushbutton_style_creator(pushbutton=button_cancel_selection)

        self.ui.upperbuttons_horizontal_layout.addWidget(combo_box)
        self.ui.upperbuttons_horizontal_layout.addWidget(button_cancel_selection)
        # Нижний лэйаут
        save_button = QPushButton()
        save_button.setText('Сохранить изменения')
        save_button.setMinimumSize(65, 25)
        save_button.setEnabled(False)
        save_button.pressed.connect(self.save_tags)
        self.save_button = save_button
        self.pushbutton_style_creator(pushbutton=save_button)

        cancel_button = QPushButton()
        cancel_button.setText('Отменить изменения')
        cancel_button.setMinimumSize(65, 25)
        cancel_button.setEnabled(False)
        cancel_button.pressed.connect(self.change_cancelling)
        self.cancel_button = cancel_button
        self.pushbutton_style_creator(pushbutton=cancel_button)

        self.ui.lowerbuttons_horizontal_layout.addWidget(save_button)
        self.ui.lowerbuttons_horizontal_layout.addWidget(cancel_button)


    def change_cancelling(self) -> None:
        for _index in self.changed_tags_indexes_list:
            self.list_widget_mass[_index].clear()
            self.list_widget_mass[_index].addItems(self.previous_tags_mass[_index])

        self.cancel_button.setEnabled(False)
        self.save_button.setEnabled(False)


    def save_tags(self) -> None:
        current_tags_list = self.all_tags_mass_creating()

        if platform.startswith("win"):
            db_name = "winDataBase.db"
        else:
            db_name = "linDataBase.db"

        with sqlite3.connect(db_name) as db:
            cursor = db.cursor()
            for i in self.changed_tags_indexes_list:
                _file_path = self.paths_to_all_files_list[i]
                _file_id = stat(_file_path, follow_symlinks=False).st_ino
                _file_in_db = cursor.execute("SELECT tags FROM media_files WHERE file_id = ?", (_file_id,)).fetchone()
                new_tags = ""

                for tag in current_tags_list[i]:
                    new_tags += f"{tag},"

                new_tags = new_tags[:-1]
                # Изменение тегов в бд (файл уже загружен)
                if _file_in_db:
                    if new_tags:
                        cursor.execute("UPDATE media_files SET tags = ? WHERE file_id = ?", (new_tags, _file_id))

                    else:
                        cursor.execute("DELETE FROM media_files WHERE file_id = ?", (_file_id,))
                # Добавление нового файла в бд
                elif new_tags:
                    # Windows
                    if db_name.startswith("win"): # Дописать
                        print(_file_path)
                        _disk_name = _file_id
                        # cursor.execute("INSERT INTO media_files VALUES(?, ?, ?)", ())
                    # Linux/Mac OS
                    else:
                        device_id = stat(_file_path, follow_symlinks=False).st_dev
                        cursor.execute("INSERT INTO media_files VALUES(?, ?, ?)", (device_id, _file_id, new_tags))

            db.commit()

        self.cancel_button.setEnabled(False)
        self.save_button.setEnabled(False)



    def right_block_cleaner(self) -> None:
        self.layout_cleaner(layout=self.ui.verticalLayout_right_window)
        self.button_cancel_selection.setEnabled(False)
        self.right_window_is_open = False
        self.first_pressed_index = -1
        self.second_pressed_index = -1

        for _ in range(len(self.selected_files_mass)):
            self.selected_files_mass[_].setStyleSheet(
                "QPushButton {background-color: white; border-radius: 7px; border: 1px solid #8a8a8a}"
                "QPushButton::hover {background-color: #dedede;}"
                "QPushButton::pressed {background-color: #dadada;}")

        self.selected_files_mass = []
        self.selected_files_way_mass = []

        self.window_resize(type_="left_window_opening")

        # self.photo_button_mass[self.previous_button_index].setStyleSheet(
        #     "QPushButton {background-color: white; border-radius: 7px; border: 1px solid #8a8a8a}"
        #     "QPushButton::hover {background-color: #dedede;}"
        #     "QPushButton::pressed {background-color: #dadada;}")


    def right_window_creating(self, pressed_button_index: int) -> None:
        """
        Функция создает расширенное главное окно с увеличенными медиафайлами.

        :param pressed_button_index: Индекс нажатого медиафайла.
        """
        if self.right_block_create_test(pressed_button_index=pressed_button_index):
            print(f'Ready to create a block! Selection_type = {self.selection_type}')
            self.window_resize(type_="right_window_opening")
            # Создание блока с фотографией
            if self.button_is_photo_mass[pressed_button_index]:
                self.photo_block_creating(pressed_button_index)
            # Создание блока с видео
            else:
                pass

            self.right_window_is_open = True
            self.button_cancel_selection.setEnabled(True)


    def photo_block_creating(self, pressed_button_index: int) -> None:
        back_widget = QWidget()
        back_widget.setMaximumSize(600, 700)
        back_widget.setStyleSheet('QWidget {background-color: #f0f0f0; border: 1px solid #b9b9b9;}')

        local_vertical_layout = QVBoxLayout(back_widget)

        label = QLabel()
        label.setText("")
        label.setAlignment(Qt.AlignCenter)
        label.setStyleSheet("QLabel {border: 0px solid black;}")
        label.setMaximumSize(700, 500)
        self.right_window_label = label
        self.pressed_button_index = pressed_button_index

        spacer = QSpacerItem(1, 1, QSizePolicy.Expanding, QSizePolicy.Expanding)
        local_vertical_layout.addItem(spacer)
        local_vertical_layout.addWidget(label)

        spacer = QSpacerItem(1, 1, QSizePolicy.Expanding, QSizePolicy.Expanding)
        local_vertical_layout.addItem(spacer)

        horizontal_buttons_layout = QHBoxLayout()

        left_arrow = QPushButton()
        left_arrow.setText('<<')
        left_arrow.setMinimumSize(65, 25)
        self.left_arrow = left_arrow
        self.pushbutton_style_creator(left_arrow)
        left_arrow.pressed.connect(lambda: self.arrow_button_pressing(side="left"))

        right_arrow = QPushButton()
        right_arrow.setText('>>')
        right_arrow.setMinimumSize(65, 25)
        self.right_arrow = right_arrow
        self.pushbutton_style_creator(pushbutton=right_arrow)
        right_arrow.pressed.connect(lambda: self.arrow_button_pressing(side="right"))

        self.previous_button_index = pressed_button_index

        if pressed_button_index == 0:
            left_arrow.setEnabled(False)

        elif pressed_button_index == len(self.photo_button_mass) - 1:
            right_arrow.setEnabled(False)

        horizontal_buttons_layout.addWidget(left_arrow)
        horizontal_buttons_layout.addWidget(right_arrow)
        local_vertical_layout.addLayout(horizontal_buttons_layout)
        self.ui.verticalLayout_right_window.addWidget(back_widget)


    def right_window_changing(self, pressed_button_index: int) -> None:
        """
        :param self.previous_button_index: индекс предпоследней нажатой кнопки.
        :param selection_type: способ выделения фотографий (1 - одиночное, 2 - от и до, 3 - выборочное).
        :param selected_photo_mass: массив с указателями на кнопки выбранных фотографий.
        :param ready_to_create_block: флаг = True, когда выполнятся все условия для открытия блока
                                      для одного из вариантов выделения.
        :param pressed_button_index: Индекс нажатой кнопки.
        :param first_pressed_index: индекс первого нажатого элемента.
        :param second_pressed_index: индекс второго нажатого элемента.
        """
        if not self.right_window_is_open:
            self.right_window_creating(pressed_button_index=pressed_button_index)
            return

        if self.selection_type == 1:
            # Если выбрана фотография
            if self.button_is_photo_mass[pressed_button_index]:
                self.photo_button_mass[self.previous_button_index].setStyleSheet(
                    "QPushButton {background-color: white; border-radius: 7px; border: 1px solid #8a8a8a}"
                    "QPushButton::hover {background-color: #dedede;}"
                    "QPushButton::pressed {background-color: #dadada;}")

                self.photo_button_mass[pressed_button_index].setStyleSheet(
                    "QPushButton {background-color: #dadada; border-radius: 7px; border: 1px solid #8a8a8a}"
                    "QPushButton::hover {background-color: #dedede;}"
                    "QPushButton::pressed {background-color: #dadada;}")

                pixmap = QPixmap(self.paths_to_all_files_list[pressed_button_index]).scaled(600, 400, aspectRatioMode=Qt.KeepAspectRatioByExpanding)
                self.right_window_label.setPixmap(pixmap)

                self.previous_button_index = pressed_button_index

                if pressed_button_index == 0:
                    self.left_arrow.setEnabled(False)
                    self.right_arrow.setEnabled(True)

                elif pressed_button_index == len(self.paths_to_all_files_list) - 1:
                    self.right_arrow.setEnabled(False)
                    self.left_arrow.setEnabled(True)

                else:
                    self.left_arrow.setEnabled(True)
                    self.right_arrow.setEnabled(True)
            # Если выбрано видео
            else:
                pass

        elif self.selection_type == 2:
            pass

        else:
            pass

        self.button_cancel_selection.setEnabled(True)


    def right_block_create_test(self, pressed_button_index: int):
        """
        Функция проверяет, выполнены ли все условия для создания расширенного окна с медиафайлами.
        """
        # Одиночное выделение
        if self.selection_type == 1:
            self.photo_button_mass[pressed_button_index].setStyleSheet(
                "QPushButton {background-color: #dadada; border-radius: 7px; border: 1px solid #8a8a8a}"
                "QPushButton::hover {background-color: #dedede;}"
                "QPushButton::pressed {background-color: #dadada;}")

            self.selected_files_mass = [self.photo_button_mass[pressed_button_index]]
            self.selected_files_way_mass = [self.paths_to_all_files_list[pressed_button_index]]
            return True
        # Выделение "от и до"
        elif self.selection_type == 2:
            return self.from_to_selection(pressed_button_index=pressed_button_index)
        # Выборочное выделение
        else:
            return self.selective_selection(pressed_button_index=pressed_button_index)


    def from_to_selection(self, pressed_button_index: int) -> bool:
        # Указание начала промежутка
        if self.first_pressed_index == -1:
            self.first_pressed_index = pressed_button_index
            self.photo_button_mass[pressed_button_index].setStyleSheet(
                "QPushButton {background-color: #dadada; border-radius: 7px; border: 1px solid #8a8a8a}"
                "QPushButton::hover {background-color: #dedede;}"
                "QPushButton::pressed {background-color: #dadada;}")
        # Указание конца промежутка
        elif self.second_pressed_index == -1:
            self.second_pressed_index = pressed_button_index
            # Если изначально был выбран конец промежутка, а не начало
            if self.first_pressed_index > self.second_pressed_index:
                self.first_pressed_index, self.second_pressed_index = self.second_pressed_index, self.first_pressed_index

            for i in range(self.first_pressed_index + 1, self.second_pressed_index + 1):
                self.photo_button_mass[i].setStyleSheet(
                    "QPushButton {background-color: #dadada; border-radius: 7px; border: 1px solid #8a8a8a}"
                    "QPushButton::hover {background-color: #dedede;}"
                    "QPushButton::pressed {background-color: #dadada;}")

            self.selected_files_mass = self.photo_button_mass[self.first_pressed_index:self.second_pressed_index + 1]
            self.selected_files_way_mass = self.paths_to_all_files_list[self.first_pressed_index:self.second_pressed_index + 1]

            return #True  # Раскомментировать, когда допишу функцию right_block_creator

        else: # Уже выбран промежуток (изменение промежутка)
            # Изменение начала промежутка
            if pressed_button_index < self.first_pressed_index:
                for i in range(pressed_button_index, self.first_pressed_index):
                    self.photo_button_mass[i].setStyleSheet(
                        "QPushButton {background-color: #dadada; border-radius: 7px; border: 1px solid #8a8a8a}"
                        "QPushButton::hover {background-color: #dedede;}"
                        "QPushButton::pressed {background-color: #dadada;}")

                self.first_pressed_index = pressed_button_index
            # Изменение конца промежутка
            elif pressed_button_index > self.second_pressed_index:
                for i in range(self.second_pressed_index + 1, pressed_button_index + 1):
                    self.photo_button_mass[i].setStyleSheet(
                        "QPushButton {background-color: #dadada; border-radius: 7px; border: 1px solid #8a8a8a}"
                        "QPushButton::hover {background-color: #dedede;}"
                        "QPushButton::pressed {background-color: #dadada;}")

                self.second_pressed_index = pressed_button_index
            # Обрезание промежутка (выбрана кнопка из диапазона)
            elif pressed_button_index > self.first_pressed_index and pressed_button_index < self.second_pressed_index:
                # Обрезаем начало (расстояние от начала до выбранного индекса наименьшее)
                if (pressed_button_index - self.first_pressed_index) < (self.second_pressed_index - pressed_button_index):
                    for i in range(self.first_pressed_index, pressed_button_index):
                        self.photo_button_mass[i].setStyleSheet(
                            "QPushButton {background-color: white; border-radius: 7px; border: 1px solid #8a8a8a}"
                            "QPushButton::hover {background-color: #dedede;}"
                            "QPushButton::pressed {background-color: #dadada;}")

                    self.first_pressed_index = pressed_button_index
                # Обрезаем конец
                else:
                    for i in range(pressed_button_index + 1, self.second_pressed_index + 1):
                        self.photo_button_mass[i].setStyleSheet(
                            "QPushButton {background-color: white; border-radius: 7px; border: 1px solid #8a8a8a}"
                            "QPushButton::hover {background-color: #dedede;}"
                            "QPushButton::pressed {background-color: #dadada;}")

                    self.second_pressed_index = pressed_button_index

            self.selected_files_mass = self.photo_button_mass[self.first_pressed_index:self.second_pressed_index + 1]
            self.selected_files_way_mass = self.paths_to_all_files_list[self.first_pressed_index:self.second_pressed_index + 1]

            return #True # Раскомментировать, когда допишу функцию right_block_creator
        return


    def selective_selection(self, pressed_button_index: int) -> bool:
        """
        :return: Функция возвращает True, если выполнены все условия для открытия right_block.
        """

        if self.paths_to_all_files_list[pressed_button_index] in self.selected_files_way_mass:
            self.photo_button_mass[pressed_button_index].setStyleSheet(
                "QPushButton {background-color: white; border-radius: 7px; border: 1px solid #8a8a8a}"
                "QPushButton::hover {background-color: #dedede;}"
                "QPushButton::pressed {background-color: #dadada;}")

            self.selected_files_way_mass.pop(pressed_button_index)
            self.selected_files_mass.pop(pressed_button_index)

        else:
            self.selected_files_way_mass.append(self.paths_to_all_files_list[pressed_button_index])
            self.selected_files_mass.append(self.photo_button_mass[pressed_button_index])

            self.photo_button_mass[pressed_button_index].setStyleSheet(
                "QPushButton {background-color: #dadada; border-radius: 7px; border: 1px solid #8a8a8a}"
                "QPushButton::hover {background-color: #dedede;}"
                "QPushButton::pressed {background-color: #dadada;}")

        if len(self.selected_files_mass) > 1:
            return #True

        else:
            self.button_cancel_selection.setEnabled(False)
            return


    def arrow_button_pressing(self, side: str):
        """
        Функция перелистывания медиафайлов в right_block.

        :param side: Переменная, обозначающая сторону, в которую будет выполняться перелистывание.
        """
        if self.selection_type == 1:
            if side == "left":
                self.photo_button_mass[self.previous_button_index].setStyleSheet(
                    "QPushButton {background-color: white; border-radius: 7px; border: 1px solid #8a8a8a}"
                    "QPushButton::hover {background-color: #dedede;}"
                    "QPushButton::pressed {background-color: #dadada;}")
                self.photo_button_mass[self.previous_button_index - 1].setStyleSheet(
                    "QPushButton {background-color: #dadada; border-radius: 7px; border: 1px solid #8a8a8a}"
                    "QPushButton::hover {background-color: #dedede;}"
                    "QPushButton::pressed {background-color: #dadada;}")

                icon_way = self.paths_to_all_files_list[self.previous_button_index - 1]
                self.selected_files_mass = [self.photo_button_mass[self.previous_button_index - 1]]
                self.selected_files_way_mass = [self.paths_to_all_files_list[self.previous_button_index - 1]]
                self.previous_button_index -= 1

                self.animated_pixmap_change_1(icon_way=icon_way, duration=100)

                if self.previous_button_index == 0:
                    self.left_arrow.setEnabled(False)

                if not(self.right_arrow.isEnabled()):
                    self.right_arrow.setEnabled(True)
            # side = "right"
            else:
                self.photo_button_mass[self.previous_button_index].setStyleSheet(
                    "QPushButton {background-color: white; border-radius: 7px; border: 1px solid #8a8a8a}"
                    "QPushButton::hover {background-color: #dedede;}"
                    "QPushButton::pressed {background-color: #dadada;}")

                self.photo_button_mass[self.previous_button_index + 1].setStyleSheet(
                    "QPushButton {background-color: #dadada; border-radius: 7px; border: 1px solid #8a8a8a}"
                    "QPushButton::hover {background-color: #dedede;}"
                    "QPushButton::pressed {background-color: #dadada;}")

                self.selected_files_mass = [self.photo_button_mass[self.previous_button_index + 1]]
                self.selected_files_way_mass = [self.paths_to_all_files_list[self.previous_button_index + 1]]
                icon_way = self.paths_to_all_files_list[self.previous_button_index + 1]
                self.previous_button_index += 1

                self.animated_pixmap_change_1(icon_way=icon_way, duration=100)

                if self.previous_button_index == len(self.photo_button_mass) - 1:
                    self.right_arrow.setEnabled(False)

                if not(self.left_arrow.isEnabled()):
                    self.left_arrow.setEnabled(True)


    def animated_pixmap_change_1(self, icon_way: str, duration: int) -> None:
        self.animated_pixmap_change_shadow_init(duration=duration)
        self.shadow_effect.fading_animation_start()
        self.shadow_effect.animation.finished.connect(lambda: self.animated_pixmap_change_2(icon_way,
                                                                                            values=(1, 0),
                                                                                            duration=duration))


    def animated_pixmap_change_2(self, icon_way: str, values: tuple, duration: int) -> None:
        opacity_effect = QGraphicsOpacityEffect(self.right_window_label)
        self.right_window_label.setGraphicsEffect(opacity_effect)
        self.opacity_animation = QPropertyAnimation(opacity_effect, b"opacity")
        self.opacity_animation.setDuration(duration)
        self.opacity_animation.setStartValue(values[0])
        self.opacity_animation.setEndValue(values[1])
        self.opacity_animation.start()
        # Функция вызвана от animated_pixmap_changing_1
        if values[0] == 1:
            self.opacity_animation.finished.connect(lambda: self.animated_pixmap_change_3(icon_way,
                                                                                          duration=duration))
        # Функция вызвана от animated_pixmap_changing_3
        else:
            self.opacity_animation.finished.connect(lambda: self.animated_pixmap_change_4(duration=duration))


    def animated_pixmap_change_3(self, icon_way: str, duration: int) -> None:
        pixmap = QPixmap(icon_way).scaled(600, 400, aspectRatioMode=Qt.KeepAspectRatioByExpanding)
        self.right_window_label.setPixmap(pixmap)
        self.animated_pixmap_change_2(icon_way, values=(0, 1), duration=duration)


    def animated_pixmap_change_4(self, duration: int) -> None:
        self.animated_pixmap_change_shadow_init(duration=duration)
        self.right_window_label.setGraphicsEffect(self.shadow_effect)
        self.shadow_effect.rise_animation_start()


    def animated_pixmap_change_shadow_init(self, duration: int) -> None:
        self.shadow_effect = AnimatedShadowEffect()
        self.shadow_effect.animation.setDuration(duration)
        self.shadow_effect.setXOffset(0)
        self.shadow_effect.setYOffset(0)


    def add_tag(self, index_: int) -> None:
        """
        Функция добавляет тег(и) в list widgets.

        :param index_: Индекс измененного медиафайла. Равен -1, когда пользователь хочет добавить тег нажатием 'Enter'.
        """
        # Нажатие на кнопку +
        if index_ != -1:
            line_edit_text = self.line_edits_mass[index_].text()
            self.changed_tags_indexes_list.add(index_)

            if line_edit_text:
                already_exist_tags = []

                for i in range(self.list_widget_mass[index_].count()):
                    already_exist_tags.append(self.list_widget_mass[index_].item(i).text().lower())

                line_edit_text = line_edit_text.split(',')
                line_edit_text = list(set(line_edit_text))

                if already_exist_tags:
                    for tag in line_edit_text:
                        tag = tag.strip()

                        if tag != ' ' and tag != '' and tag.lower() not in already_exist_tags:
                            self.list_widget_mass[index_].addItem(tag)

                else:
                    for tag in line_edit_text:
                        tag = tag.strip()

                        if tag != ' ' and tag != '':
                            self.list_widget_mass[index_].addItem(tag)

                self.line_edits_mass[index_].clear()
        # Функция вызвана нажатием кнопки Enter
        else:
            for i in range(len(self.line_edits_mass)):
                if self.line_edits_mass[i].text() != '':
                    self.changed_tags_indexes_list.add(i)
                    self.add_tag(index_=i)
            return

        self.previous_and_present_tags_equal_test()


    def delete_tag(self, index_: int) -> None:
        """
        Функция удаляет тег(и) из list widgets.

        :param index_: Индекс измененного медиафайла.
        """
        a = self.list_widget_mass[index_].selectedIndexes()
        _selected_index = self.list_widget_mass[index_].count() - 1
        _items_mass = []

        for i in a:
            _selected_index = i.row()

        # Очистка и обратное заполнение listWidget
        for i in range(self.list_widget_mass[index_].count()):
            if i != _selected_index:
                item = self.list_widget_mass[index_].item(i)
                name = item.text()
                foreground = item.foreground()
                _items_mass.append([name, foreground])

        self.list_widget_mass[index_].clear()

        for i in range(len(_items_mass)):
            new_item = QListWidgetItem()
            new_item.setText(_items_mass[i][0])
            new_item.setForeground(_items_mass[i][1])
            self.list_widget_mass[index_].addItem(new_item)

        self.previous_and_present_tags_equal_test()


    def previous_and_present_tags_equal_test(self) -> None:
        present_tags = self.all_tags_mass_creating()
        is_equal = True

        for i in self.changed_tags_indexes_list:
            # Проверка на содержание одинаковых элементов
            if Counter(present_tags[i]) != Counter(self.previous_tags_mass[i]):
                if not self.save_button.isEnabled():
                    self.save_button.setEnabled(True)
                    self.cancel_button.setEnabled(True)

                is_equal = False
                break

        if is_equal:
            self.save_button.setEnabled(False)
            self.cancel_button.setEnabled(False)


    def all_tags_mass_creating(self) -> list:
        """
        :return: Двумерный массив со всеми тегами.
        """
        all_tags_mass = []

        for i in range(len(self.list_widget_mass)):
            _mass = []
            if self.list_widget_mass[i].count() != 0:
                for j in range(self.list_widget_mass[i].count()):
                    _mass.append(self.list_widget_mass[i].item(j).text())
            # добавляем в двумерный массив либо пустые массивы, если в лв нет тегов, либо массив с элементами лв
            all_tags_mass.append(_mass)

        return all_tags_mass


    def layout_cleaner(self, layout: object) -> None:
        """
        Функция полностью очищает содержимое заданного на вход layout.
        """
        if layout is not None:
            while layout.count():
                item = layout.takeAt(0)
                widget = item.widget()

                if widget is not None:
                    widget.setParent(None)
                else:
                    self.layout_cleaner(layout=item.layout())


    def keyPressEvent(self, e) -> None:
        # Главное окно с медиафайлами
        if self.ui.tabWidget.currentIndex() == 0:
            if e.key() == Qt.Key_Return:
                self.add_tag(index_=-1)


    @staticmethod
    def db_init() -> None:
        """
        Функция инициализирует базу данных при запуске программы.
        """
        if platform.startswith("win"):
            with sqlite3.connect("winDataBase.db") as db:
                cursor = db.cursor()
                cursor.execute(""" CREATE TABLE IF NOT EXISTS media_files (disk_name TEXT, file_id TEXT, tags TEXT) """)
                db.commit()

        elif platform == "darwin" or platform.startswith("linux"):
            with sqlite3.connect("linDataBase.db") as db:
                cursor = db.cursor()
                cursor.execute(""" CREATE TABLE IF NOT EXISTS media_files (device_id TEXT, file_id TEXT, tags TEXT) """)
                db.commit()

        else:
            sys.exit("The platform is not supported")


    def window_resize(self, type_: str) -> None:
        """
        Функция автоматического изменения размера окна.

        :param type_: Переменная, отвечающая за вид изменения размера.
        """
        tab_index = self.ui.tabWidget.currentIndex()
        # Первый запуск программы
        if type_ == 'start':
            self.animation = QPropertyAnimation(self, b"size")
            self.animation.setDuration(500)
            self.animation.setEasingCurve(QEasingCurve.Linear)
            self.animation.setStartValue(QSize(20, 20))
            self.animation.setEndValue(QSize(500, 540))
            self.animation.start(QPropertyAnimation.DeleteWhenStopped)
        # Переключение между вкладками программы
        elif type_ == "change":
            # Проверка на несохраненные значения в окне настроек  
            if self.LastIndex == 1 and self.ui.pushButton_save_settings.isEnabled():
                error_message = QMessageBox()
                error_message.setWindowTitle('Изменение настроек')
                error_message.setWindowIcon(QIcon('icons/save_or_not.png'))
                error_message.setText("Вы хотите сохранить изменения?      ")
                error_message.setStandardButtons(QMessageBox.Yes | QMessageBox.No)

                result = error_message.exec_()

                if result == QMessageBox.Yes:
                    self.save_settings()
                else:
                    self.ui.settings_init() #### Проверить!!!

        elif type_ == "left_window_opening": # Добавить зависимость от кол-ва фотографий в папке
            self.move_window(xy_shift=((application.size().width() - 600) // 2,
                                       (application.size().height() - 700) // 2),
                             new_size=(600, 700), type_="left_window_opening")

        elif type_ == "right_window_opening": # Добавить зависимость от кол-ва фотографий в папке
            self.move_window(xy_shift=((application.size().width() - 1250) // 2,
                                       (application.size().height() - 730) // 2),
                             new_size=(1250, 730), type_="right_window_opening")

        self.LastIndex = tab_index


    def move_window(self, xy_shift: tuple, new_size: tuple, type_: str) -> None:
        """
        Функция изменяет размер окна и одновременно перемещает его
        для избежания выхода за границы экрана.

        :param xy_shift: Кортеж со значениями, на которые нужно переместить окно.
        :param new_size: Кортеж с новым размером окна.
        :param type_: Строка, содержащая тип анимации.
        """
        new_coordinates = (application.geometry().x() + xy_shift[0],
                           application.geometry().y() + xy_shift[1])

        self.move_animation = QPropertyAnimation(self, b"geometry")
        self.move_animation.setDuration(1125)
        self.move_animation.setEasingCurve(QEasingCurve.OutCirc)
        self.move_animation.setStartValue(application.geometry())
        self.move_animation.setEndValue(QRect(new_coordinates[0], new_coordinates[1],
                                              new_size[0], new_size[1]))

        if type_ == "left_window_opening":
            self.move_animation.start()

        elif type_ == "right_window_opening":
            self.move_animation.start()
            self.move_animation.finished.connect(self.pixmap_creation)


    def pixmap_creation(self) -> None:
        """
        Функция добавляет pixmap к label в окне для просмотра увеличенных медиафайлов.
        """
        # self.right_window_label.setStyleSheet("QLabel {border: 0px solid black;}")

        pixmap = QPixmap(self.paths_to_all_files_list[self.pressed_button_index]).scaled(
            600, 400, aspectRatioMode=Qt.KeepAspectRatioByExpanding)
        self.right_window_label.setPixmap(pixmap)

        opacity_effect = QGraphicsOpacityEffect(self.right_window_label)
        self.right_window_label.setGraphicsEffect(opacity_effect)
        self.opacity_animation = QPropertyAnimation(opacity_effect, b"opacity")
        self.opacity_animation.setDuration(700)
        self.opacity_animation.setStartValue(0)
        self.opacity_animation.setEndValue(1)
        self.opacity_animation.start()
        self.opacity_animation.finished.connect(self.label_shadow_effect_init)


    def label_shadow_effect_init(self):
        self.shadow_effect = AnimatedShadowEffect()
        self.shadow_effect.setYOffset(0)
        self.shadow_effect.setXOffset(0)
        self.shadow_effect.animation.setDuration(700)

        self.right_window_label.setGraphicsEffect(self.shadow_effect)
        self.shadow_effect.rise_animation_start()


    def pushbutton_style_creator(self, pushbutton: QWidget) -> None:
        pushbutton.setStyleSheet("QPushButton {background-color: #c7c7c7; "
                                 "border-radius: 7px; border: 1px solid #8a8a8a}"
                                 "QPushButton::hover {background-color: #dedede;}"
                                 "QPushButton::pressed {background-color: #dadada;}")
        self.set_shadow_effect(object_=pushbutton)


    @staticmethod
    def set_shadow_effect(object_: QWidget) -> None:
        shadow = QGraphicsDropShadowEffect()
        shadow.setBlurRadius(4)
        shadow.setXOffset(0)
        shadow.setYOffset(0)
        object_.setGraphicsEffect(shadow)


# Установка иконки приложения для Windows
try:
    from PyQt5.QtWinExtras import QtWin
    myAppId = 'mycompany.myproduct.subproduct.version'
    QtWin.setCurrentProcessExplicitAppUserModelID(myAppId)
except ImportError:
    pass


if __name__ == '__main__':
    monitor_size = ()

    for monitor in get_monitors():
        if monitor.is_primary:
            monitor_size = (monitor.width, monitor.height)
    # Не найден ни один монитор
    if len(monitor_size) == 0:
        raise OSError

    app = QApplication([])
    app.setWindowIcon(QIcon("icons/WindowIcon.icns"))
    app.setStyle(QStyleFactory.keys()[-1])
    application = MMBody()
    application.move(monitor_size[0] // 2 - 250, monitor_size[1] // 2 - 270)
    application.setWindowIcon(QIcon("icons/WindowIcon.icns"))
    application.show()
    sys.exit(app.exec_())






    # def ToolTip_enable(self, duration = 1):
    # if self.ui.checkBox_setting1.isChecked():
    #     duration = 5000
    #
    # for button in self.ui.pushButton_input_mass:
    #     button.setToolTipDuration(duration)
    # for button in self.ui.pushButton_category_delete_mass:
    #     button.setToolTipDuration(duration)
    # for button in self.ui.pushButton_categories_color_mass:
    #     button.setToolTipDuration(duration)
    # for button in self.ui.pushButton_category_change_priority_mass:
    #     button.setToolTipDuration(duration)
    # self.ui.pushButton_addcategory.setToolTipDuration(duration)
    # self.ui.listWidget_history_tags.setToolTipDuration(duration)
    # self.ui.pushButton_deletecategory.setToolTipDuration(duration)

    # Добавление тегов
    # def add_tags(self, called_by):
    #
    #     if called_by != -1: # Нажатие на кнопку
    #         if self.ui.lineEdit_tags_mass[called_by].text() != '':
    #             tags_mass = []
    #
    #             # Добавление тегов, написанных через запятую
    #             if ',' in self.ui.lineEdit_tags_mass[called_by].text():
    #                 tags_mass = self.ui.lineEdit_tags_mass[called_by].text().split(',')
    #             else: tags_mass.append(self.ui.lineEdit_tags_mass[called_by].text())
    #             #
    #             tags_mass = list(set(tags_mass))
    #
    #             for i in range(tags_mass.count('')): tags_mass.pop(tags_mass.index('')) # Удаление пустых тэгов из массива
    #
    #             if len(tags_mass) != 0:
    #
    #                 for i in range(len(tags_mass)):
    #                     tags_mass[i] = tags_mass[i].strip()
    #                     item = QtWidgets.QListWidgetItem()
    #                     item.setText(tags_mass[i][0].upper() + tags_mass[i][1:])
    #
    #                     if self.category_colors_mass[called_by] == 0:
    #                         item.setForeground(QtGui.QColor('green'))
    #                         self.tags_priority[called_by].append(0)
    #                     else:
    #                         item.setForeground(QtGui.QColor('blue'))
    #                         self.tags_priority[called_by].append(1)
    #
    #                     self.ui.listWidget_mass[called_by].addItem(item)
    #
    #
    #                 self.ui.pushButton_load.setEnabled(True)
    #                 self.ui.pushButton_open.setEnabled(True)
    #                 self.ui.pushButton_delete_files.setEnabled(True)
    #                 self.ui.pushButton_category_delete_mass[called_by].setEnabled(True)
    #                 self.ui.pushButton_category_change_priority_mass[called_by].setEnabled(True)
    #                 if not(self.ui.pushButton_categories_color_mass[called_by].isEnabled()):
    #                     self.ui.pushButton_categories_color_mass[called_by].setEnabled(True)
    #                     self.ui.pushButton_categories_color_mass[called_by].setStyleSheet("QPushButton {"
    #                                                                               "background-color: #3CFF00; border-radius: 7px; border: 1px solid #8a8a8a}"
    #                                                                               "QPushButton::hover {background-color: #83FF5C;}")
    #
    #
    #             self.ui.lineEdit_tags_mass[called_by].clear()
    #
    #     else:  # Нажатие на Enter
    #         for i in range(len(self.ui.lineEdit_tags_mass)):
    #             if self.ui.lineEdit_tags_mass[i].text() != '':
    #                 tags_mass = []
    #
    #                 # Добавление тегов, написанных через запятую
    #                 if ',' in self.ui.lineEdit_tags_mass[i].text():
    #                     tags_mass = self.ui.lineEdit_tags_mass[i].text().split(',')
    #                 else:
    #                     tags_mass.append(self.ui.lineEdit_tags_mass[i].text())
    #                 #
    #                 tags_mass = list(set(tags_mass))
    #
    #                 for j in range(tags_mass.count('')): tags_mass.pop(tags_mass.index(''))  # Удаление пустых тэгов из массива
    #                 for j in range(tags_mass.count(' ')): tags_mass.pop(tags_mass.index(' '))
    #
    #                 for _ in range(self.ui.listWidget_mass[i].count()): # Удаление уже существующих тегов
    #                     _tag = self.ui.listWidget_mass[i].item(_).text().lower()
    #                     if _tag in tags_mass: del tags_mass[tags_mass.index(_tag)]
    #
    #
    #                 if len(tags_mass) != 0:
    #                     for j in range(len(tags_mass)):
    #                         tags_mass[j] = tags_mass[j].strip()
    #                         item = QtWidgets.QListWidgetItem()
    #                         item.setText(tags_mass[j][0].upper() + tags_mass[j][1:])
    #                         self.ui.listWidget_mass[i].addItem(item)
    #
    #                         if not(self.ui.pushButton_categories_color_mass[i].isEnabled()):
    #                             self.ui.pushButton_categories_color_mass[i].setEnabled(True)
    #                             self.ui.pushButton_categories_color_mass[i].setStyleSheet("QPushButton {"
    #                                                                                       "background-color: #3CFF00; border-radius: 7px; border: 1px solid #8a8a8a}"
    #                                                                                       "QPushButton::hover {background-color: #83FF5C;}")
    #                             item.setForeground(QtGui.QColor('green'))
    #                             self.tags_priority[i].append(0)
    #
    #                         else:
    #                             if self.category_colors_mass[i] == 0:
    #                                 item.setForeground(QtGui.QColor('green'))
    #                                 self.tags_priority[i].append(0)
    #                             else:
    #                                 item.setForeground(QtGui.QColor('blue'))
    #                                 self.tags_priority[i].append(1)
    #
    #                         self.ui.pushButton_category_change_priority_mass[i].setEnabled(True)
    #
    #                     self.ui.pushButton_load.setEnabled(True)
    #                     self.ui.pushButton_open.setEnabled(True)
    #                     self.ui.pushButton_delete_files.setEnabled(True)
    #                     self.ui.pushButton_category_delete_mass[i].setEnabled(True)
    #
    #
    #                 self.ui.lineEdit_tags_mass[i].clear()

    # # Удаление тегов
    # def delete_tags(self, called_by, _lw_count_flag=True):
    #     a = self.ui.listWidget_mass[called_by].selectedIndexes()
    #
    #     _selected_index = self.ui.listWidget_mass[called_by].count() - 1
    #     _items_mass = []
    #
    #     for i in a: _selected_index = i.row()
    #
    #     # Очистка и обратное заполнение listWidget
    #     for i in range(self.ui.listWidget_mass[called_by].count()):
    #         if i != _selected_index:
    #             item = self.ui.listWidget_mass[called_by].item(i)
    #             name = item.text()
    #             foreground = item.foreground()
    #             _items_mass.append([name, foreground])
    #
    #     self.ui.listWidget_mass[called_by].clear()
    #
    #     for i in range(len(_items_mass)):
    #         newItem = QtWidgets.QListWidgetItem()
    #         newItem.setText(_items_mass[i][0])
    #         newItem.setForeground(_items_mass[i][1])
    #         self.ui.listWidget_mass[called_by].addItem(newItem)
    #     #
    #
    #
    #     if self.ui.listWidget_mass[called_by].count() == 0:
    #         self.category_colors_mass[called_by] = 0
    #         self.ui.pushButton_category_delete_mass[called_by].setEnabled(False)
    #         self.ui.pushButton_categories_color_mass[called_by].setEnabled(False)
    #         self.ui.pushButton_category_change_priority_mass[called_by].setEnabled(False)
    #         self.ui.pushButton_category_change_priority_mass[called_by].setIcon(QtGui.QIcon("icons/gr.png"))
    #         self.ui.pushButton_categories_color_mass[called_by].setStyleSheet("QPushButton {"
    #                                                                "background-color: #c7c7c7; border-radius: 7px; border: 1px solid #8a8a8a}"
    #                                                                "QPushButton::hover {background-color: #dedede;}")
    #
    #         # Проверка на пустоту всех лист виджетов
    #         for j in range(len(self.ui.listWidget_mass)):
    #             if j != called_by:
    #                 if self.ui.listWidget_mass[j].count() != 0:
    #                     _lw_count_flag = False
    #
    #         if _lw_count_flag == True:
    #
    #             self.ui.pushButton_load.setEnabled(False)
    #             self.ui.pushButton_open.setEnabled(False)
    #             self.ui.pushButton_delete_files.setEnabled(False)
    #
    # def tags_splitting(self, file_way: str) -> list:
    #     """
    #     :return: Возвращаем массив с тегами, созданными по имени файла.
    #     """
    #     # Удаление пути файла, оставляем только поле с тегами
    #     file_way = file_way.split('{')
    #     file_way = file_way[-1]
    #
    #     # Удаление формата файла в конце строки
    #     file_way = file_way.split('.')
    #     file_way = file_way[0]
    #
    #     tags_mass = file_way.split(',')
    #
    #     for i in range(len(tags_mass)):
    #         tags_mass[i] = tags_mass[i].strip()
    #
    #     return tags_mass
    #
    # # Добавление категорий на странице "Категории тегов"
    # def add_category(self):
    #     if self.ui.lineEdit_category.text() != '':
    #
    #         tags_mass = []
    #         mass = [self.ui.listWidget_categories.item(row).text().lower() for row in
    #                 range(self.ui.listWidget_categories.count())]  # Получение элементов в listWidget
    #
    #         self.previous_categories = mass
    #
    #         # Добавление тегов, написанных через запятую
    #         if ',' in self.ui.lineEdit_category.text():
    #             tags_mass = self.ui.lineEdit_category.text().split(',')
    #         else:
    #             tags_mass.append(self.ui.lineEdit_category.text())
    #         #
    #         tags_mass = list(set(tags_mass))
    #
    #         for i in range(tags_mass.count('')): tags_mass.pop(tags_mass.index(''))  # Удаление пустых тэгов из массива
    #
    #         if self.ui.listWidget_categories.count() + len(tags_mass) <= 8:
    #
    #             self.ui.listWidget_categories.clear()
    #
    #             if len(tags_mass) != 0:
    #
    #                 for i in range(len(tags_mass)): # Добавление новых тегов
    #                     tags_mass[i] = tags_mass[i].strip()
    #                     if tags_mass[i].lower() not in mass:
    #                         item = QtWidgets.QListWidgetItem()
    #                         item.setText(tags_mass[i][0].upper() + tags_mass[i][1:])
    #                         self.ui.listWidget_categories.addItem(item)
    #
    #                 for i in range(len(mass)): # Добавление старых тегов
    #                     item = QtWidgets.QListWidgetItem()
    #                     item.setText(mass[i][0].upper() + mass[i][1:])
    #                     self.ui.listWidget_categories.addItem(item)
    #
    #                 self.ui.pushButton_save_changes.setEnabled(True)
    #                 self.ui.pushButton_cancel_changes.setEnabled(True)
    #                 self.ui.pushButton_deletecategory.setEnabled(True)
    #
    #
    #
    #
    #         else:  # Вывод ошибки
    #             error_message = QtWidgets.QMessageBox()
    #             error_message.setWindowTitle('Ошибка!')
    #             error_message.setText("Невозможно добавить больше 8 категорий")
    #             error_message.setWindowIcon(QtGui.QIcon('icons/remove.png'))
    #             error_message.setDefaultButton(QtWidgets.QMessageBox.Yes)
    #
    #             error_message.exec_()
    #
    #         self.ui.lineEdit_category.clear()
    #
    #     mass = [self.ui.listWidget_categories.item(row).text().lower() for row in
    #             range(self.ui.listWidget_categories.count())]  # Получение элементов в listWidget
    #
    #     if mass == self.ui.categories_mass:  # Все исходные категории сохранились
    #         self.ui.pushButton_save_changes.setEnabled(False)
    #         self.ui.pushButton_cancel_changes.setEnabled(False)

    # # Удаление категорий на странице "Категории тегов"
    # def delete_category(self): #flag = False
    #     print(self.ui.categories_mass)
    #     a = self.ui.listWidget_categories.selectedIndexes()
    #
    #     if not(a):
    #         self.ui.listWidget_categories.takeItem(0)
    #
    #     else:
    #         for i in a: self.ui.listWidget_categories.takeItem(i.row())
    #
    #     # for i in a:
    #     #     _category = (self.ui.listWidget_categories.item(i.row()).text().lower())
    #     #
    #     #     if _category in self.ui.white_history_categories:
    #     #         _index = self.ui.white_history_categories.index(_category)
    #     #
    #     #         self.ui.grey_history_categories.append(_category)
    #     #         self.ui.grey_history_tags.append(self.ui.white_history_tags[_index])
    #     #
    #     #         self.ui.white_history_categories = self.ui.white_history_categories[:_index] + self.ui.white_history_categories[_index+1:]
    #     #         self.ui.white_history_tags = self.ui.white_history_tags[:_index] + self.ui.white_history_tags[_index+1:]
    #     #
    #     #         self.ui.listWidget_categories.takeItem(i.row())
    #     #         flag = True
    #
    #
    #     # if flag == False:
    #     #     _category = (self.ui.listWidget_categories.item(self.ui.listWidget_categories.count() - 1).text().lower())
    #     #     _index = self.ui.listWidget_categories.count() - 1
    #     #
    #     #     self.ui.listWidget_categories.takeItem(self.ui.listWidget_categories.count() - 1)
    #
    #     if self.ui.listWidget_categories.count() == 0:
    #         self.ui.pushButton_deletecategory.setEnabled(False)
    #
    #     mass = [self.ui.listWidget_categories.item(row).text().lower() for row in
    #             range(self.ui.listWidget_categories.count())]  # Получение элементов в listWidget
    #
    #     # Все исходные категории сохранились
    #     if mass == self.ui.categories_mass: self.ui.pushButton_save_changes.setEnabled(False), \
    #                                         self.ui.pushButton_cancel_changes.setEnabled(False)
    #
    #     else: self.ui.pushButton_save_changes.setEnabled(True), \
    #           self.ui.pushButton_cancel_changes.setEnabled(True)
    #
    #
    #
    #
    # # Сохранение изменений в листе категорий
    # def save_category_changes(self):
    #     error_message = QtWidgets.QMessageBox()
    #     error_message.setWindowTitle('Изменение категорий')
    #     error_message.setWindowIcon(QtGui.QIcon('icons/save_or_not.png'))
    #     error_message.setText("Вы хотите сохранить изменения?      ")
    #     error_message.setStandardButtons(QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No)
    #
    #     result = error_message.exec_()
    #
    #     mass = [self.ui.listWidget_categories.item(row).text().lower() for row in
    #             range(self.ui.listWidget_categories.count())]  # Получение элементов в listWidget
    #
    #
    #     if result == QtWidgets.QMessageBox.Yes:
    #
    #         folder = Path(self.ui.lineEdit_files_directory.text())
    #
    #         NewCategories = [category for category in mass if category not in self.previous_categories]
    #         NewCategories = NewCategories[::-1]
    #
    #         ### Сдвиг папок
    #
    #         # Добавление новых категорий
    #         for category in NewCategories:
    #             FolderName = str(folder) + "\\" + category + '{-'
    #
    #             try:
    #                 os.mkdir(FolderName)
    #
    #                 for file in folder.iterdir():
    #                     if file.name != 'output' and file.name != category + '{-':
    #
    #                         # print(str(file), f'{FolderName}\\{file.name}')
    #                         os.replace(str(file), f'{FolderName}\\{file.name}') # (исправить) Не работает при нулевом уровне "место{-"
    #                         # print(str(file), f'{FolderName}\\{file.name}')
    #
    #             except: raise OSError
    #
    #
    #         # Удаление старых категорий
    #         def CategoryDelete(folder):
    #             folder = Path(folder)
    #             self.level_k += 1
    #
    #             for file in folder.iterdir():
    #                 if file.name != 'output':
    #                     if self.level_k < level:
    #                         CategoryDelete(str(file))
    #
    #                     else:
    #                         for file_ in file.iterdir():
    #                             os.replace(str(file_), f'{str(folder)}\\{file_.name}')
    #
    #                         shutil.rmtree(str(file))
    #
    #
    #         for category in self.previous_categories:
    #             if category not in mass: # Нашли удаленную категорию
    #                 self.level_k = -1
    #                 level = self.previous_categories.index(category)
    #
    #                 CategoryDelete(str(folder))
    #
    #         ###
    #
    #         try:
    #             with open("config.txt", "r+", encoding='utf-8') as f:
    #                 config_txt = f.readlines()
    #                 categories = mass
    #
    #                 new_config = ""
    #
    #                 for i in range(len(categories)):
    #                     if i < len(categories) - 1:
    #                         new_config += categories[i] + ','
    #                     else: new_config += categories[i]
    #
    #                 new_config += "\n"
    #
    #                 for i in range(1, len(config_txt)): new_config += config_txt[i]
    #
    #                 f.seek(0)
    #                 f.truncate()
    #                 f.write(new_config)
    #
    #         except:
    #             error_message = QtWidgets.QMessageBox()
    #             error_message.setWindowTitle('Ошибка!')
    #             error_message.setWindowIcon(QtGui.QIcon('icons/error_window_icon.png'))
    #             error_message.setText("Корневые файлы программы повреждены,\n программа нуждается в перезагрузке.")
    #             error_message.setDefaultButton(QtWidgets.QMessageBox.Yes)
    #
    #             error_message.exec_()
    #             app.exit()
    #
    #         self.ui.categories_creator(True)
    #
    #         self.ui.categories_mass = mass
    #
    #         self.ui.pushButton_save_changes.setEnabled(False)
    #         self.ui.pushButton_cancel_changes.setEnabled(False)
    # #
    #
    # # Отмена изменений в листе категорий
    # def cancel_changes(self):
    #     self.ui.listWidget_categories.clear()
    #
    #     for i in range(len(self.ui.categories_mass)):
    #         item = QtWidgets.QListWidgetItem()
    #         item.setText(self.ui.categories_mass[i][0].upper() + self.ui.categories_mass[i][1:])
    #         self.ui.listWidget_categories.addItem(item)
    #
    #     if not(self.ui.pushButton_deletecategory.isEnabled()):
    #         self.ui.pushButton_deletecategory.setEnabled(True)
    #
    #     self.ui.pushButton_cancel_changes.setEnabled(False)
    #     self.ui.pushButton_save_changes.setEnabled(False)
    # #
    #
    #
    # def recursive_load(self, folder):
    #
    #     _files = [] # Двумерный массив с тегами каждого файла
    #     folder_mass = [] # Названия файлов в папке
    #     actual_tags = []
    #     folder = Path(folder)
    #     level_category = self.ui.categories_mass[self.levels]
    #
    #
    #     for file in folder.iterdir():
    #         a = file.name.split("{")
    #
    #         if a[0] != 'output' and file.is_dir():
    #             _files.append(a[-1].split(","))  # Массив разделенных тегов
    #             folder_mass.append(str(file))
    #
    #
    #     flag = False  # Флаг на вхождение категории уровня в заданные пользователем категории
    #
    #
    #     for i in range(self.ui.listWidget_categories.count()):
    #         if self.ui.listWidget_mass[i].count() > 0 \
    #                 and level_category == self.ui.label_categories_mass[i].text().lower()[:-1]: # Категория этого уровня задана пользователем
    #
    #                 flag = True
    #                 actual_tags = []  # Теги в заданной категории конкретного уровня
    #
    #                 for ind in range(self.ui.listWidget_mass[i].count()):
    #                     actual_tags.append(self.ui.listWidget_mass[i].item(ind).text().lower())
    #
    #                 break
    #
    #     if flag:
    #         test_result = self.load_name_test(_files, actual_tags, folder_mass)
    #
    #         if test_result == False: # Нет подходящей папки
    #
    #             _name_of_new_folder = str(folder) + '\\' + level_category + '{'
    #
    #             for i in range(len(actual_tags)):
    #                 _name_of_new_folder += actual_tags[i]
    #
    #                 if i != len(actual_tags) - 1:
    #                     _name_of_new_folder += ","
    #
    #             os.mkdir(_name_of_new_folder)
    #
    #             if self.levels != len(self.ui.categories_mass) - 1: # Если мы не дошли до последнего уровня
    #                 self.levels += 1
    #                 self.recursive_load(_name_of_new_folder)
    #
    #             else:
    #                 self.files_loading(_name_of_new_folder)
    #
    #         else: # Нашлась подходящая папка
    #
    #             if self.levels != len(self.ui.categories_mass) - 1:
    #                 self.levels += 1
    #                 self.recursive_load(test_result)
    #
    #             else: # Дошли до конечной папки
    #                 self.files_loading(test_result)
    #
    #
    #     else: # Категория на данном уровне не задана
    #         _ = str(folder) + '\\' + level_category + '{-'
    #
    #         _flag = False
    #
    #         for i in _files:
    #             if '-' in i:
    #                 _flag = True
    #
    #         if not(_flag): os.mkdir(_)
    #
    #         if self.levels != len(self.ui.categories_mass) - 1:
    #             self.levels += 1
    #             self.recursive_load(_)
    #
    #         else:
    #             self.files_loading(_)
    #
    #
    # def files_loading(self, name_of_new_folder):
    #
    #     for i in range(len(self.files)):
    #         _newname = name_of_new_folder + '\\' + self.files[i].split('/')[-1]
    #
    #         if self.ui.checkBox_setting3.checkState():
    #             os.rename(self.files[i], _newname)
    #         else:
    #             shutil.copyfile(self.files[i], _newname)
    #
    #
    #
    #
    # def load_name_test(self, _files, actual_tags, folder_mass): # Проверка на вхождение папки с необходимыми тегами
    #
    #     for mass_ in _files:
    #         _local_flag = True
    #
    #         for tag in actual_tags:
    #
    #             if len(actual_tags) != len(mass_) or tag not in mass_:
    #                 _local_flag = False
    #                 break
    #
    #         if _local_flag:
    #             return (folder_mass[_files.index(mass_)])
    #
    #
    #     return False
    #
    #
    #
    #
    # def load_files(self):
    #     self.files = QtWidgets.QFileDialog.getOpenFileNames(self,
    #                                                    'Выберите несколько файлов',
    #                                                    ".",
    #                                                    "Allfiles(*.*)")[0]
    #
    #     _check_mass = []
    #
    #     self.levels = 0
    #     self.recursive_load(self.ui.lineEdit_files_directory.text())
    #
    #
    #     for a in range(8):
    #         self.ui.listWidget_mass[a].clear()
    #         self.ui.pushButton_category_delete_mass[a].setEnabled(False)
    #         self.ui.pushButton_categories_color_mass[a].setEnabled(False)
    #         self.ui.pushButton_category_change_priority_mass[a].setEnabled(False)
    #         self.ui.lineEdit_tags_mass[a].clear()
    #
    #     for i in range(len(self.ui.history_category_tags)):
    #         self.ui.history_category_tags[i].sort()
    #
    #     # self.history_recreator()   # Исправить!!!!!!!!
    #
    #     self.PushButtons_return_StyleSheet()
    #
    #     self.ui.pushButton_load.setEnabled(False)
    #     self.ui.pushButton_open.setEnabled(False)
    #     self.ui.pushButton_delete_files.setEnabled(False)
    #     self.ui.pushButton_clean_all_files.setEnabled(True)
    #
    #     self.category_colors_mass = bytearray((0, 0, 0, 0, 0, 0, 0, 0))
    #     self.tags_priority = [[], [], [], [], [], [], [], []]
    #
    #
    # def open_files(self):
    #
    #     ### Очистка файлов в папке output
    #     filelist = [f for f in os.listdir(self.ui.output_trail)]
    #     for file in filelist: os.remove(os.path.join(self.ui.output_trail, file))
    #     ###
    #
    #     self.active_categories_ind = []
    #     self.active_categories_names = []
    #
    #     ### Определяем активные категории
    #     for i in range(self.ui.listWidget_categories.count()):
    #         if self.ui.listWidget_mass[i].count() != 0:
    #             _category = self.ui.label_categories_mass[i].text().lower()[:-1]
    #             self.active_categories_ind.append(i)
    #             self.active_categories_names.append(_category)
    #     ###
    #
    #
    #     self.files_count = 0
    #     self.file_found_flag = False # Флаг на нахождение медиафайла
    #
    #     folder = self.ui.lineEdit_files_directory.text()
    #     self.recursive_search(folder)
    #
    #
    #     if self.file_found_flag:
    #         os.system(f"explorer.exe {self.ui.output_trail}")
    #     else:
    #         os_message = QtWidgets.QMessageBox()
    #         os_message.setWindowTitle(" ")
    #         os_message.setText("По заданным категориям не было найдено ни одного файла.        ")
    #         os_message.setWindowIcon(QtGui.QIcon('icons/folder.png'))
    #         os_message.setStandardButtons(QtWidgets.QMessageBox.Ok)
    #
    #         os_message.exec_()
    #
    #     # Возвращение главной страницы к исходному виду
    #     self.reload()
    #
    #
    #
    # def recursive_search(self, folder):
    #     folder = Path(folder)
    #
    #     for file in folder.iterdir():  # Перебор всех файлов в folder
    #
    #         if file.is_dir():
    #             file_name = file.name.split("'\'")[-1].split("§")
    #             file_name = file_name[0].split('{')
    #             main_flag = True
    #             blue_test = True
    #             red_tag_in = False
    #             green_test = False
    #
    #             if file_name[0] == 'output': continue
    #
    #             _index = -1
    #             folder_category = file_name[0]
    #             _list_widget_elements_mass = []  # Теги в лв по категории папки
    #             folder_category_tags = file_name[1].split(',')  # Массив с разделенными тегами в названии папки
    #
    #
    #             if folder_category in self.active_categories_names:
    #
    #                 _index = self.active_categories_ind[self.active_categories_names.index(folder_category)]
    #
    #                 _red_tags = []
    #                 _blue_tags = []
    #                 _green_tags = []
    #
    #                 for row in range(self.ui.listWidget_mass[_index].count()):
    #                     _list_widget_elements_mass.append(self.ui.listWidget_mass[_index].item(row).text().lower())
    #
    #                     if self.tags_priority[_index][row] == 0:
    #                         _green_tags.append(self.ui.listWidget_mass[_index].item(row).text().lower())
    #                     elif self.tags_priority[_index][row] == 1:
    #                         _blue_tags.append(self.ui.listWidget_mass[_index].item(row).text().lower())
    #                     else:
    #                         _red_tags.append(self.ui.listWidget_mass[_index].item(row).text().lower())
    #
    #
    #                 for tag in _red_tags:
    #                     if tag in folder_category_tags:
    #                         red_tag_in = True
    #                         break
    #
    #
    #                 if len(_green_tags) != 0:
    #                     blue_test = False
    #
    #                     for tag in _green_tags:
    #                         if tag in folder_category_tags:
    #                             green_test = True
    #                             break
    #
    #
    #                 elif len(_blue_tags) != 0:
    #                     green_test = False
    #
    #                     for tag in _blue_tags:
    #                         if tag not in folder_category_tags:
    #                             blue_test = False
    #                             break
    #
    #
    #                 if not (not (red_tag_in) and (green_test or blue_test)):
    #                     main_flag = False
    #
    #
    #             if main_flag: # Папка подошла
    #                 self.recursive_search(file)
    #
    #
    #         else: # Дошли до листьев
    #             self.files_count += 1
    #             self.file_found_flag = True
    #             newname = self.ui.output_trail + "\\" + str(self.files_count) + '.' + file.name.split('.')[-1]
    #             shutil.copyfile(file, newname)
    #
    #
    # def PushButton_delete_files(self):
    #     error_message = QtWidgets.QMessageBox()
    #     error_message.setWindowTitle('Удаление файлов')
    #     error_message.setWindowIcon(QtGui.QIcon('icons/save_or_not.png'))
    #     error_message.setText("Вы точно хотите безвозвратно удалить медиафайлы по заданным тегам?      ")
    #     error_message.setStandardButtons(QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No)
    #
    #     result = error_message.exec_()
    #
    #     if result == QtWidgets.QMessageBox.Yes:
    #
    #         folder = Path(self.ui.lineEdit_files_directory.text())
    #
    #         for file in folder.iterdir():
    #             file_name = file.name.split("'\'")[-1].split("§")
    #
    #             _flag = True  # Флаг на прохождение файла по категориям
    #             _found = False  # Флаг на нахождение хотя бы 1 категории в файле
    #
    #             # Отделяем теги от категории
    #             for i in range(len(file_name) - 1):
    #                 file_name[i] = file_name[i].split("{")
    #
    #             for i in range(self.ui.listWidget_categories.count()):
    #                 if self.ui.listWidget_mass[i].count() != 0:
    #
    #                     _list_widget_elements_mass = (self.ui.listWidget_mass[i].item(row).text().lower() for
    #                                                   row in range(self.ui.listWidget_mass[i].count()))
    #
    #                     for j in range(len(file_name) - 1):
    #                         # формат file_name[j] - (теги...), file_name[0] - категория
    #
    #                         # Нахождение нужной категории в file_name[j]
    #                         if self.ui.label_categories_mass[i].text().lower()[:-1] in file_name[j]:
    #                             _found = True
    #
    #                             _file_tags = file_name[j][-1].split(',')  # Массив с тегами
    #
    #                             # Перебор всех тегов в file_name по найденной категории
    #                             for f in range(len(_file_tags)):
    #
    #                                 if (_file_tags[f] not in _list_widget_elements_mass):
    #                                     _flag = False
    #                                     break
    #
    #                             break
    #                 if not (_flag): break
    #
    #             if _flag and _found:
    #                 os.remove(os.path.join(self.ui.sklad_trail, file.name))
    #
    #         # Возвращение главной страницы к исходному виду
    #         self.reload()
    #
    #
    # def save_settings(self):
    #
    #     try:
    #         with open("config.txt", "r+", encoding='utf-8') as f:
    #             config_txt = f.readlines()
    #             new_config = config_txt[0]
    #
    #             new_config += str(int(self.ui.checkBox_setting1.isChecked())) + ',' \
    #                           + str(int(self.ui.checkBox_setting2.isChecked())) + ',' \
    #                           + str(int(self.ui.checkBox_setting3.isChecked()))
    #
    #             new_config += "\n"
    #
    #             self.ui.settings_mass[0] = self.ui.checkBox_setting1.isChecked()
    #             self.ui.settings_mass[1] = self.ui.checkBox_setting2.isChecked()
    #             self.ui.settings_mass[2] = self.ui.checkBox_setting3.isChecked()
    #
    #             for i in range(2, len(config_txt)): new_config += config_txt[i]
    #
    #             f.seek(0)
    #             f.truncate()
    #             f.write(new_config)
    #
    #             self.ui.pushButton_save_settings.setEnabled(False)
    #             self.ui.pushButton_delete_settings.setEnabled(False)
    #
    #     except:
    #         error_message = QtWidgets.QMessageBox()
    #         error_message.setWindowTitle('Ошибка!')
    #         error_message.setWindowIcon(QtGui.QIcon('icons/error_window_icon.png'))
    #         error_message.setText("Корневые файлы программы повреждены,\n программа нуждается в перезагрузке.")
    #         error_message.setDefaultButton(QtWidgets.QMessageBox.Yes)
    #
    #         error_message.exec_()
    #         app.exit()
    #
    #
    #
    # def delete_all_files(self):
    #     error_message = QtWidgets.QMessageBox()
    #     error_message.setWindowTitle('Очистка корневой папки')
    #     error_message.setWindowIcon(QtGui.QIcon('icons/save_or_not.png'))
    #     error_message.setText("Вы точно хотите безвозвратно удалить все медиафайлы?      ")
    #     error_message.setStandardButtons(QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No)
    #
    #     result = error_message.exec_()
    #
    #     if result == QtWidgets.QMessageBox.Yes:
    #         filelist = [f for f in os.listdir(self.ui.sklad_trail)]
    #         for file in filelist:
    #             if file != 'output':
    #                 os.remove(os.path.join(self.ui.sklad_trail, file))
    #
    #         self.ui.pushButton_clean_all_files.setEnabled(False)
    #


    #
    # def eventFilter(self, obj, event):
    #     if obj == self.ui.pushButton_deletecategory:
    #         if event.type() == QtCore.QEvent.HoverEnter:
    #             self.ui.pushButton_deletecategory.setIcon(QtGui.QIcon("icons/trashOn.png"))
    #         elif event.type() == QtCore.QEvent.HoverLeave:
    #             self.ui.pushButton_deletecategory.setIcon(QtGui.QIcon("icons/trash.png"))
    #
    #     return super(MM_body, self).eventFilter(obj, event)
    #
    #
    # def change_all_item_priority(self, called_by):
    #     # print(self.category_colors_mass[called_by])
    #     if self.category_colors_mass[called_by] == 0:
    #         self.ui.pushButton_categories_color_mass[called_by].setStyleSheet("QPushButton {"
    #                                                                           "background-color: #0D2DFF; border-radius: 7px; border: 1px solid #8a8a8a}"
    #                                                                           "QPushButton::hover {background-color: #2542FF;}")
    #         self.ui.pushButton_category_change_priority_mass[called_by].setIcon(QtGui.QIcon("icons/br.png"))
    #
    #     else:
    #         self.ui.pushButton_categories_color_mass[called_by].setStyleSheet("QPushButton {"
    #                                                                           "background-color: #3CFF00; border-radius: 7px; border: 1px solid #8a8a8a}"
    #                                                                           "QPushButton::hover {background-color: #83FF5C;}")
    #         self.ui.pushButton_category_change_priority_mass[called_by].setIcon(QtGui.QIcon("icons/gr.png"))
    #     # print('da')
    #     if self.category_colors_mass[called_by] < len(self.colors) - 2:
    #         self.category_colors_mass[called_by] += 1
    #     else:
    #         self.category_colors_mass[called_by] = 0
    #     # print(self.category_colors_mass[called_by])
    #     for row in range(self.ui.listWidget_mass[called_by].count()):
    #         # print(f'row = {row}\n{self.tags_priority}')
    #         if self.tags_priority[called_by][row] != len(self.colors) - 1: # Проверка на то, что тег не красный
    #             # print(self.tags_priority)
    #             # print(self.tags_priority[called_by][row])
    #             self.ui.listWidget_mass[called_by].item(row).setForeground(
    #                 QtGui.QColor(self.colors[self.category_colors_mass[called_by]]))
    #             # print(self.tags_priority[called_by][row] )
    #             self.tags_priority[called_by][row] = self.category_colors_mass[called_by]
    #
    #
    #
    # def change_item_priority(self, called_by, _flag = False):
    #     a = self.ui.listWidget_mass[called_by].selectedIndexes()
    #
    #     # Убираем выделение эл-та
    #     _items_mass = []
    #
    #     for i in a: _selected_index = i.row()
    #
    #     for i in range(self.ui.listWidget_mass[called_by].count()):
    #         item = self.ui.listWidget_mass[called_by].item(i)
    #         name = item.text()
    #         foreground = item.foreground()
    #         _items_mass.append([name, foreground])
    #
    #     self.ui.listWidget_mass[called_by].clear()
    #
    #     for i in range(len(_items_mass)):
    #         newItem = QtWidgets.QListWidgetItem()
    #         newItem.setText(_items_mass[i][0])
    #         newItem.setForeground(_items_mass[i][1])
    #         self.ui.listWidget_mass[called_by].addItem(newItem)
    #     #
    #
    #
    #     for i in a:
    #         # Изменение индекса цвета для выбранного эл-та
    #
    #         if self.tags_priority[called_by][i.row()] == self.category_colors_mass[called_by]:
    #             self.tags_priority[called_by][i.row()] = len(self.colors) - 1
    #         else: self.tags_priority[called_by][i.row()] = self.category_colors_mass[called_by]
    #
    #         # Изменение цвета эл-та
    #         self.ui.listWidget_mass[called_by].item(i.row()).setForeground(QtGui.QColor(self.colors[self.tags_priority[called_by][i.row()]]))
    #         _flag = True
    #
    #     if _flag == False:
    #         # Изменение индекса цвета для последнего эл-та
    #         if self.tags_priority[called_by][-1] == self.category_colors_mass[called_by]:
    #             self.tags_priority[called_by][-1] = len(self.colors) - 1
    #         else: self.tags_priority[called_by][-1] = self.category_colors_mass[called_by]
    #
    #         self.ui.listWidget_mass[called_by].item(self.ui.listWidget_mass[called_by].count() - 1).setForeground(QtGui.QColor(self.colors[self.tags_priority[called_by][-1]]))
    #
    #
    #
    #
    # def check_box_func(self):
    #     if (self.ui.checkBox_setting1.isChecked() == self.ui.settings_mass[0]) \
    #             and (self.ui.checkBox_setting2.isChecked() == self.ui.settings_mass[1]) \
    #             and (self.ui.checkBox_setting3.isChecked() == self.ui.settings_mass[2]):
    #         self.ui.pushButton_save_settings.setEnabled(False)
    #         self.ui.pushButton_delete_settings.setEnabled(False)
    #
    #     else:
    #         self.ui.pushButton_save_settings.setEnabled(True)
    #         self.ui.pushButton_delete_settings.setEnabled(True)
    #
    #
    #
    # def PushButtons_return_StyleSheet(self):
    #     for i in range(self.ui.listWidget_categories.count()):
    #         self.ui.pushButton_categories_color_mass[i].setStyleSheet("QPushButton {"
    #                                                                "background-color: #c7c7c7; border-radius: 7px; border: 1px solid #8a8a8a}"
    #                                                                "QPushButton::hover {background-color: #dedede;}"
    #                                                                "QPushButton::pressed {background-color: #dadada;}")
    #
    #
    # def listWidget_history_tags_creator(self):
    #
    #     self.ui.listWidget_history_tags.clear()
    #     index = self.ui.listWidget_history_all_categories.currentRow()
    #
    #
    #     if index <= len(self.ui.white_history_tags) - 1:
    #         self.ui.listWidget_history_tags.setEnabled(True)
    #
    #         for j in range(len(self.ui.white_history_tags[index])):
    #             item = QtWidgets.QListWidgetItem()
    #             item.setText(self.ui.white_history_tags[index][j][0].upper() + self.ui.white_history_tags[index][j][1:])
    #             item.setTextAlignment(QtCore.Qt.AlignHCenter)
    #
    #             self.ui.listWidget_history_tags.addItem(item)
    #
    #     else:
    #         index -= len(self.ui.white_history_tags)
    #         for i in range(len(self.ui.grey_history_tags[index])):
    #             item = QtWidgets.QListWidgetItem()
    #             item.setText(self.ui.grey_history_tags[index][i][0].upper() + self.ui.grey_history_tags[index][i][1:])
    #             item.setTextAlignment(QtCore.Qt.AlignHCenter)
    #
    #             self.ui.listWidget_history_tags.addItem(item)
    #         self.ui.listWidget_history_tags.setEnabled(False)
    #
    #     self.window_resize("change")
    #
    #
    # def history_recreator(self):
    #     self.ui.listWidget_history_tags.clear()
    #     self.ui.listWidget_history_all_categories.clear()
    #
    #     for i in range(len(self.ui.history_files_categories)):
    #         item = QtWidgets.QListWidgetItem()
    #         item.setText(self.ui.history_files_categories[i][0].upper() + self.ui.history_files_categories[i][1:])
    #         item.setTextAlignment(QtCore.Qt.AlignHCenter)
    #
    #         self.ui.listWidget_history_all_categories.addItem(item)
    #
    #     for j in range(len(self.ui.history_category_tags[0])):
    #         item = QtWidgets.QListWidgetItem()
    #         item.setText(self.ui.history_category_tags[0][j][0].upper() + self.ui.history_category_tags[0][j][1:])
    #         item.setTextAlignment(QtCore.Qt.AlignHCenter)
    #
    #         self.ui.listWidget_history_tags.addItem(item)
    #
    #     self.ui.listWidget_history_all_categories.item(0).setSelected(True)
    #
    #
    #
    # def add_tags_from_history(self):
    #     a = self.ui.listWidget_history_tags.selectedIndexes()
    #     b = self.ui.listWidget_history_all_categories.selectedIndexes()
    #     for i in a: _pressed_itemIndex = i.row()
    #     for i in b: _selected_categoryIndex = i.row()
    #
    #     for i in range(len(self.ui.label_categories_mass)):
    #         # Нахождение нужной категории на главной странице
    #         if self.ui.label_categories_mass[i].text().lower()[:-1] == self.ui.listWidget_history_all_categories.item(_selected_categoryIndex).text().lower():
    #
    #             self.ui.lineEdit_tags_mass[i].setText(self.ui.listWidget_history_tags.item(_pressed_itemIndex).text())
    #             self.add_tags(i)
    #             break
    #
    #
    #
    # # Возвращение главной страницы к исходному виду
    # def reload(self):
    #     self.category_colors_mass = bytearray((0, 0, 0, 0, 0, 0, 0, 0))
    #     self.tags_priority = [[], [], [], [], [], [], [], []]
    #
    #     for i in range(self.ui.listWidget_categories.count()):
    #         self.ui.listWidget_mass[i].clear()
    #         self.ui.pushButton_open.setEnabled(False)
    #         self.ui.pushButton_load.setEnabled(False)
    #         self.ui.pushButton_delete_files.setEnabled(False)
    #         self.ui.pushButton_category_delete_mass[i].setEnabled(False)
    #         self.ui.pushButton_categories_color_mass[i].setEnabled(False)
    #         self.ui.pushButton_category_change_priority_mass[i].setEnabled(False)
    #
    #     self.PushButtons_return_StyleSheet()
